{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"photoelastimetry","text":"<p>Package for processing polarised images to measure stress in granular media</p>"},{"location":"#installation","title":"Installation","text":"<p>To install the package, run the following command in the terminal:</p> <pre><code>pip install photoelastimetry\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>Full documentation is available here.</p>"},{"location":"#usage","title":"Usage","text":"<p>After installation, two command line scripts are available:</p>"},{"location":"#image-to-stress","title":"image-to-stress","text":"<p>Converts photoelastic images to stress maps using the stress-optic law and polarisation analysis.</p> <pre><code>image-to-stress &lt;json_filename&gt; [--output OUTPUT]\n</code></pre> <p>Arguments:</p> <ul> <li><code>json_filename</code>: Path to the JSON5 parameter file containing configuration (required)</li> <li><code>--output</code>: Path to save the output stress map image (optional)</li> </ul> <p>Example:</p> <pre><code>image-to-stress params.json5 --output stress_map.png\n</code></pre> <p>The JSON5 parameter file should contain:</p> <ul> <li><code>folderName</code>: Path to folder containing raw photoelastic images</li> <li><code>C</code>: Stress-optic coefficient in 1/Pa</li> <li><code>thickness</code>: Sample thickness in meters</li> <li><code>wavelengths</code>: List of wavelengths in nanometers</li> <li><code>S_i_hat</code>: Incoming normalized Stokes vector [S1_hat, S2_hat, S3_hat] representing polarization state</li> <li><code>crop</code> (optional): Crop region as [y1, y2, x1, x2]</li> <li><code>debug</code> (optional): If true, display all channels for debugging</li> </ul>"},{"location":"#stress-to-image","title":"stress-to-image","text":"<p>Converts stress field data to photoelastic fringe pattern images.</p> <pre><code>stress-to-image &lt;json_filename&gt;\n</code></pre> <p>Arguments:</p> <ul> <li><code>json_filename</code>: Path to the JSON5 parameter file containing configuration (required)</li> </ul> <p>Example:</p> <pre><code>stress-to-image params.json5\n</code></pre> <p>The JSON5 parameter file should contain:</p> <ul> <li><code>p_filename</code>: Path to the photoelastimetry parameter file</li> <li><code>stress_filename</code>: Path to the stress field data file</li> <li><code>t</code>: Thickness of the photoelastic material</li> <li><code>lambda_light</code>: Wavelength of light used in the experiment</li> <li><code>C</code>: Stress-optic coefficient of the material</li> <li><code>scattering</code> (optional): Gaussian filter sigma for scattering simulation</li> <li><code>output_filename</code> (optional): Path for the output image (default: \"output.png\")</li> </ul>"},{"location":"#demosaic-raw","title":"demosaic-raw","text":"<p>De-mosaics a raw polarimetric image from a camera with a 4x4 superpixel pattern into separate colour and polarisation channels.</p> <pre><code>demosaic-raw &lt;input_file&gt; [--width WIDTH] [--height HEIGHT] [--dtype DTYPE] [--output-prefix PREFIX] [--format FORMAT] [--all]\n</code></pre> <p>Arguments:</p> <ul> <li><code>input_file</code>: Path to the raw image file, or directory when using <code>--all</code> (required)</li> <li><code>--width</code>: Image width in pixels (default: 4096)</li> <li><code>--height</code>: Image height in pixels (default: 3000)</li> <li><code>--dtype</code>: Data type, either 'uint8' or 'uint16' (auto-detected if not specified)</li> <li><code>--output-prefix</code>: Prefix for output files (default: input filename without extension)</li> <li><code>--format</code>: Output format, either 'tiff' or 'png' (default: 'tiff')</li> <li><code>--all</code>: Recursively process all .raw files in the input directory and subdirectories</li> </ul> <p>Examples:</p> <pre><code># Save as a single TIFF stack\ndemosaic-raw image.raw --width 2448 --height 2048 --dtype uint16 --format tiff\n\n# Save as four separate PNG files (one per polarisation angle)\ndemosaic-raw image.raw --width 2448 --height 2048 --format png --output-prefix output\n\n# Process all raw files in a directory recursively\ndemosaic-raw images/ --format png --all\n</code></pre> <p>Output formats:</p> <ul> <li><code>tiff</code>: Creates a single TIFF file with shape [H/4, W/4, 4, 4] containing all colour channels (R, G1, G2, B) and polarisation angles (0\u00b0, 45\u00b0, 90\u00b0, 135\u00b0)</li> <li><code>png</code>: Creates 4 PNG files (one per polarisation angle), each containing all colour channels as a composite image</li> </ul>"},{"location":"#development","title":"Development","text":"<p>To set up the development environment, clone the repository and install the package in editable mode with development dependencies:</p> <pre><code>git clone https://github.com/benjym/photoelastimetry.git\ncd photoelastimetry\npip install -e \".[dev]\"\n# Set up pre-commit hooks\npre-commit install\n</code></pre>"},{"location":"#running-tests","title":"Running Tests","text":"<p>The project uses <code>pytest</code> for testing with comprehensive coverage analysis:</p> <pre><code># Run all tests\npytest\n\n# Run tests with coverage report\npytest --cov=photoelastimetry --cov-report=html\n\n# Run specific test file\npytest tests/test_stokes_solver_pytest.py -v\n\n# Run tests in parallel (faster)\npytest -n auto\n</code></pre>"},{"location":"#code-coverage","title":"Code Coverage","text":"<p>View the coverage report by opening <code>htmlcov/index.html</code> in your browser after running tests with coverage enabled.</p> <p>Current test coverage includes: - Stokes solver: photoelastic stress recovery using normalised Stokes parameters - Intensity solver: raw intensity-based stress recovery with noise modelling - Equilibrium solver: global stress field recovery enforcing mechanical equilibrium - Disk simulations: synthetic photoelastic data generation - Image processing: retardance, principal angle, and Mueller matrix calculations</p>"},{"location":"#code-quality","title":"Code Quality","text":"<p>The project uses <code>black</code> for code formatting and <code>flake8</code> for linting:</p> <pre><code># Format code\nblack photoelastimetry tests\n\n# Check code style\nflake8 photoelastimetry\n</code></pre>"},{"location":"#continuous-integration","title":"Continuous Integration","text":"<p>GitHub Actions automatically runs tests on: - Python 3.9, 3.10, 3.11, and 3.12 - Multiple operating systems (Ubuntu) - Every push and pull request</p> <p>Test coverage is automatically uploaded to Codecov for tracking.</p>"},{"location":"#authors","title":"Authors","text":"<ul> <li>Benjy Marks</li> <li>Qianyu Fang</li> </ul>"},{"location":"#usage_1","title":"Usage","text":"<p>The code is run by calling <code>python photoelastimetry/local.py &lt;json5 file&gt;</code>. The parameters for the experiment are stored in the <code>json5</code> file. The default parameters, contained in <code>json/params.json5</code> are as follows:</p> <pre><code>{\n    // Incoming normalized Stokes vector [S1_hat, S2_hat, S3_hat]\n    // For linear polarizer at 0\u00b0: [1.0, 0.0, 0.0]\n    // For linear polarizer at 45\u00b0: [0.0, 1.0, 0.0]\n    // For circular polarizer: [0.0, 0.0, 1.0]\n    S_i_hat : [1.0, 0.0, 0.0], // Incoming polarization state\n    wavelengths : [650, 550, 450], // R, G, B wavelengths (nm)\n    C : [2e-12,2e-12,2e-12], // stress-optic coefficient for each wavelength (1/Pa)\n    thickness : 0.01, // thickness of sample in m\n    polarisation_efficiency : 0.95,\n    folderName : \"images/2025_05_06/2025_05_06_11_51_53_010/02002060_diskSaving1\",\n    debug: false\n}\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for your interest in contributing to Photoelastimetry! This guide will help you get started.</p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<ol> <li>Clone the repository:</li> </ol> <pre><code>git clone https://github.com/benjym/photoelastimetry.git\ncd photoelastimetry\n</code></pre> <ol> <li>Install in editable mode:</li> </ol> <pre><code>pip install -e .\n</code></pre> <p>This installs the package in development mode, allowing you to make changes and test them immediately.</p>"},{"location":"contributing/#code-style","title":"Code Style","text":"<p>The project uses automated code formatting and linting:</p>"},{"location":"contributing/#black","title":"Black","text":"<p>Code is formatted using Black with a line length of 110 characters:</p> <pre><code>black photoelastimetry/\n</code></pre>"},{"location":"contributing/#flake8","title":"Flake8","text":"<p>Code is checked using Flake8:</p> <pre><code>flake8 photoelastimetry/\n</code></pre>"},{"location":"contributing/#pre-commit-hooks","title":"Pre-commit Hooks","text":"<p>Pre-commit hooks are set up to automatically format code before commits:</p> <pre><code>pre-commit install\n</code></pre> <p>This will run Black and Flake8 automatically on your changes before each commit.</p>"},{"location":"contributing/#testing","title":"Testing","text":"<p>Before submitting changes, ensure your code works correctly:</p> <pre><code># Run any existing tests\npython test_local.py\n\n# Test command-line tools\nimage-to-stress --help\nstress-to-image --help\ndemosaic-raw --help\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":""},{"location":"contributing/#building-documentation-locally","title":"Building Documentation Locally","text":"<p>The documentation is built using MkDocs:</p> <pre><code>mkdocs serve\n</code></pre> <p>This starts a local server at <code>http://127.0.0.1:8000</code> where you can preview your documentation changes.</p> <p>To build the documentation:</p> <pre><code>mkdocs build\n</code></pre>"},{"location":"contributing/#writing-documentation","title":"Writing Documentation","text":"<ul> <li>Docstrings: Use NumPy-style docstrings for all public functions and classes</li> <li>Examples: Include examples in docstrings where appropriate</li> <li>User Guides: Update user guides when adding new features</li> </ul> <p>Example docstring format:</p> <pre><code>def compute_stress(I, C, t, wavelength):\n    \"\"\"\n    Compute stress from intensity measurements.\n\n    Parameters\n    ----------\n    I : ndarray\n        Intensity measurements with shape (H, W, 4)\n    C : float\n        Stress-optic coefficient in 1/Pa\n    t : float\n        Sample thickness in meters\n    wavelength : float\n        Light wavelength in meters\n\n    Returns\n    -------\n    stress : ndarray\n        Stress tensor with shape (H, W, 3) containing\n        [sigma_xx, sigma_yy, sigma_xy]\n\n    Examples\n    --------\n    &gt;&gt;&gt; I = np.random.rand(100, 100, 4)\n    &gt;&gt;&gt; stress = compute_stress(I, 5e-11, 0.005, 550e-9)\n    &gt;&gt;&gt; stress.shape\n    (100, 100, 3)\n    \"\"\"\n    # Implementation\n    pass\n</code></pre>"},{"location":"contributing/#submitting-changes","title":"Submitting Changes","text":"<ol> <li>Create a new branch:</li> </ol> <pre><code>git checkout -b feature/your-feature-name\n</code></pre> <ol> <li>Make your changes and commit them:</li> </ol> <pre><code>git add .\ngit commit -m \"Add feature: description of your changes\"\n</code></pre> <ol> <li>Push to GitHub:</li> </ol> <pre><code>git push origin feature/your-feature-name\n</code></pre> <ol> <li>Create a Pull Request on GitHub with a clear description of your changes.</li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<ul> <li>Write clear, descriptive commit messages</li> <li>Update documentation for new features</li> <li>Add examples if appropriate</li> <li>Ensure code passes Black and Flake8 checks</li> <li>Test your changes thoroughly</li> </ul>"},{"location":"contributing/#reporting-issues","title":"Reporting Issues","text":"<p>When reporting issues, please include:</p> <ul> <li>Python version</li> <li>Operating system</li> <li>Steps to reproduce the issue</li> <li>Expected vs actual behavior</li> <li>Error messages and stack traces</li> </ul>"},{"location":"contributing/#questions","title":"Questions?","text":"<p>If you have questions about contributing, feel free to:</p> <ul> <li>Open an issue on GitHub</li> <li>Contact the maintainers:</li> <li>Benjy Marks</li> <li>Qianyu Fang</li> </ul>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Please be respectful and constructive in all interactions with the community. We aim to maintain a welcoming environment for all contributors.</p>"},{"location":"contributing/#license","title":"License","text":"<p>By contributing to Photoelastimetry, you agree that your contributions will be licensed under the GPL-3.0-or-later license.</p>"},{"location":"examples/","title":"Examples","text":"<p>This page provides practical examples for using the photoelastimetry package.</p>"},{"location":"examples/#example-1-elastic-disk-solution","title":"Example 1: Elastic Disk Solution","text":"<p>You can generate a pre-set disk stress solution for validation using the parameters in <code>json/test.json5</code>:</p> <pre><code>python photoelastimetry/disk.py\n</code></pre> <p>This can be inverted to recover the stress field using the standard solvers via</p> <pre><code>image-to-stress json/test.json5\n</code></pre>"},{"location":"examples/#example-2-basic-stress-analysis","title":"Example 2: Basic Stress Analysis","text":"<p>Analyze a set of photoelastic images to extract stress fields:</p> <pre><code>import photoelastimetry.solver as solver\nimport numpy as np\n\n# Load your polarimetric images (4 angles: 0\u00b0, 45\u00b0, 90\u00b0, 135\u00b0)\nI0 = np.load('image_0deg.npy')\nI45 = np.load('image_45deg.npy')\nI90 = np.load('image_90deg.npy')\nI135 = np.load('image_135deg.npy')\n\n# Stack intensities\nintensities = np.stack([I0, I45, I90, I135], axis=-1)\n\n# Compute Stokes components\nS = solver.compute_stokes_components(intensities)\n\n# Normalize Stokes components\nS_normalized = solver.compute_normalized_stokes(S)\n\n# Material properties\nC = 5e-11  # Stress-optic coefficient (1/Pa)\nt = 0.005  # Sample thickness (m)\nwavelength = 550e-9  # Wavelength (m)\nnu = 1.0  # Solid fraction\n\n# Recover stress field\nstress_map = solver.recover_stress_map_stokes(\n    S_normalized, C, nu, t, wavelength\n)\n\n# Extract stress components\nsigma_xx = stress_map[..., 0]\nsigma_yy = stress_map[..., 1]\nsigma_xy = stress_map[..., 2]\n</code></pre>"},{"location":"examples/#example-3-using-command-line-tools","title":"Example 3: Using Command Line Tools","text":""},{"location":"examples/#process-raw-images","title":"Process Raw Images","text":"<pre><code># First, demosaic raw polarimetric images\ndemosaic-raw raw_images/ --width 2448 --height 2048 --format png --all\n\n# Create a parameter file (params.json5)\ncat &gt; params.json5 &lt;&lt; EOF\n{\n  \"folderName\": \"./raw_images\",\n  \"C\": 5e-11,\n  \"thickness\": 0.005,\n  \"wavelengths\": [450, 550, 650],\n  \"S_i_hat\": [1.0, 0.0, 0.0],\n  \"crop\": [200, 1800, 200, 2200],\n  \"debug\": false\n}\nEOF\n\n# Run stress analysis\nimage-to-stress params.json5 --output stress_field.png\n</code></pre>"},{"location":"examples/#example-4-comparing-solver-methods","title":"Example 4: Comparing Solver Methods","text":"<p>Compare results from different stress inversion methods:</p> <pre><code>import photoelastimetry.solver.intensity_solver as intensity_solver\nimport photoelastimetry.solver.stokes_solver as stokes_solver\n\n# Using intensity-based method\nstress_intensity = intensity_solver.recover_stress_map_intensity(\n    intensities, C, nu, t, wavelength\n)\n\n# Using Stokes-based method\nS = stokes_solver.compute_stokes_components(intensities)\nS_norm = stokes_solver.compute_normalized_stokes(S)\nstress_stokes = stokes_solver.recover_stress_map_stokes(\n    S_norm, C, nu, t, wavelength\n)\n\n# Compare methods\ncomparison = intensity_solver.compare_stokes_vs_intensity(\n    intensities, C, nu, t, wavelength\n)\n</code></pre>"},{"location":"examples/#example-5-global-equilibrium-solver","title":"Example 5: Global Equilibrium Solver","text":"<p>Use the equilibrium-based solver for mechanical consistency:</p> <pre><code>import photoelastimetry.solver.equilibrium_solver as eq_solver\n\n# First get local solution\nstress_local = solver.recover_stress_map_stokes(\n    S_normalized, C, nu, t, wavelength\n)\n\n# Grid spacing\ndx = 1.0  # meters\ndy = 1.0  # meters\n\n# Refine using equilibrium constraints\nstress_global = eq_solver.recover_stress_field_global(\n    stress_local, dx, dy, max_iterations=1000\n)\n\n# Compare local vs global solutions\ncomparison = eq_solver.compare_local_vs_global(\n    stress_local, stress_global, dx, dy\n)\n</code></pre>"},{"location":"examples/#example-6-forward-simulation","title":"Example 6: Forward Simulation","text":"<p>Generate synthetic photoelastic images from known stress fields:</p> <pre><code># Create parameter file for forward simulation\ncat &gt; forward_params.json5 &lt;&lt; EOF\n{\n  \"p_filename\": \"experimental_params.json5\",\n  \"stress_filename\": \"stress_field.npy\",\n  \"t\": 0.005,\n  \"lambda_light\": 550e-9,\n  \"C\": 5e-11,\n  \"scattering\": 2.0,\n  \"output_filename\": \"synthetic_image.png\"\n}\nEOF\n\n# Run forward simulation\nstress-to-image forward_params.json5\n</code></pre>"},{"location":"examples/#additional-resources","title":"Additional Resources","text":"<ul> <li>See the API Reference for detailed function documentation</li> <li>Check the User Guide for parameter explanations</li> <li>Visit the GitHub repository for more examples</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>To install the package, run the following command in the terminal:</p> <pre><code>pip install photoelastimetry\n</code></pre>"},{"location":"getting-started/#quick-start","title":"Quick Start","text":"<p>After installation, three command line scripts are available for different photoelasticity workflows:</p>"},{"location":"getting-started/#image-to-stress","title":"image-to-stress","text":"<p>Convert photoelastic images to stress maps:</p> <pre><code>image-to-stress params.json5 --output stress_map.png\n</code></pre>"},{"location":"getting-started/#stress-to-image","title":"stress-to-image","text":"<p>Generate photoelastic fringe patterns from stress fields:</p> <pre><code>stress-to-image params.json5\n</code></pre>"},{"location":"getting-started/#demosaic-raw","title":"demosaic-raw","text":"<p>Process raw polarimetric images from specialized cameras:</p> <pre><code>demosaic-raw image.raw --width 2448 --height 2048 --format tiff\n</code></pre>"},{"location":"getting-started/#configuration","title":"Configuration","text":"<p>All tools use JSON5 parameter files for configuration. See the User Guide for detailed parameter descriptions.</p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Read the User Guide for detailed usage instructions</li> <li>Check the Examples for practical demonstrations</li> <li>Browse the API Reference for module documentation</li> </ul>"},{"location":"testing/","title":"Test Suite Documentation","text":""},{"location":"testing/#overview","title":"Overview","text":"<p>The photoelastimetry package includes a comprehensive test suite using <code>pytest</code> to ensure code quality and correctness. Tests are organized by module and cover unit tests, integration tests, and edge cases.</p>"},{"location":"testing/#test-structure","title":"Test Structure","text":"<pre><code>tests/\n\u251c\u2500\u2500 __init__.py                       # Test package initialization\n\u251c\u2500\u2500 test_stokes_solver_pytest.py      # Stokes-based stress recovery tests\n\u251c\u2500\u2500 test_intensity_solver.py          # Intensity-based stress recovery tests\n\u251c\u2500\u2500 test_equilibrium_solver.py        # Equilibrium-constrained recovery tests\n\u251c\u2500\u2500 test_disk.py                      # Disk simulation and synthetic data tests\n\u251c\u2500\u2500 test_image_io.py                  # Image processing and I/O tests\n\u2514\u2500\u2500 test_stokes_solver.py             # Legacy comprehensive tests (kept for reference)\n</code></pre>"},{"location":"testing/#test-coverage-by-module","title":"Test Coverage by Module","text":""},{"location":"testing/#stokes-solver-test_stokes_solver_pytestpy","title":"Stokes Solver (<code>test_stokes_solver_pytest.py</code>)","text":"<p>Tests for the Stokes-based photoelastic stress recovery:</p> <ul> <li>Stokes Components: Computation of S0, S1, S2 from four-step polarimetry</li> <li>Normalized Stokes: Normalization and edge case handling (zero S0)</li> <li>Retardance: Computation from stress tensor using stress-optic law</li> <li>Principal Angle: Determination of stress orientation</li> <li>Mueller Matrix: Wave plate birefringence modeling</li> <li>Forward Model: Predicting Stokes parameters from known stress</li> <li>Stress Recovery: Inverse problem solving for stress tensor</li> <li>Solid Fraction: Light attenuation through granular media</li> <li>Stress Mapping: Full-field stress recovery from image stacks</li> </ul> <p>Key Features Tested: - Multi-wavelength RGB approach - Uniaxial and biaxial stress states - Shear stress recovery - Principal stress difference accuracy</p>"},{"location":"testing/#intensity-solver-test_intensity_solverpy","title":"Intensity Solver (<code>test_intensity_solver.py</code>)","text":"<p>Tests for raw intensity-based stress recovery:</p> <ul> <li>Intensity Prediction: Forward model from stress to intensity</li> <li>Residual Computation: Optimization objective function</li> <li>Stress Recovery: Least-squares fitting with noise modeling</li> <li>Weighted Recovery: Measurement confidence weighting</li> <li>Bounded Optimization: Constrained parameter estimation</li> <li>Stress Mapping: Full-field intensity-based recovery</li> <li>Stokes Comparison: Validation against Stokes method</li> </ul> <p>Key Features Tested: - Four-step polarimetry (0\u00b0, 45\u00b0, 90\u00b0, 135\u00b0) - Multi-wavelength RGB measurements - Optimization methods (Levenberg-Marquardt, Trust Region) - Initial guess sensitivity - Bounds and constraints</p>"},{"location":"testing/#equilibrium-solver-test_equilibrium_solverpy","title":"Equilibrium Solver (<code>test_equilibrium_solver.py</code>)","text":"<p>Tests for global equilibrium-constrained stress recovery:</p> <ul> <li>Finite Differences: Second derivative operators for equilibrium</li> <li>Airy Stress Function: Conversion to stress tensor</li> <li>Global Residual: Combined data and equilibrium constraints</li> <li>Global Recovery: Optimization with equilibrium enforcement</li> <li>Iterative Methods: Progressive refinement strategies</li> <li>Local vs Global: Comparison of pixel-wise vs field-based approaches</li> <li>Equilibrium Enforcement: Mechanical consistency verification</li> </ul> <p>Key Features Tested: - Grid-based finite difference operators - Airy function properties (constant \u2192 zero stress) - Masked regions and boundaries - Smoothness regularization - Equilibrium equation satisfaction</p>"},{"location":"testing/#disk-simulations-test_diskpy","title":"Disk Simulations (<code>test_disk.py</code>)","text":"<p>Tests for synthetic photoelastic data generation:</p> <ul> <li>Four-Step Polarimetry: Mueller calculus-based simulation</li> <li>Wavelength Dependence: Dispersion effects</li> <li>Stress Dependence: Intensity variation with stress magnitude</li> <li>Synthetic Disk Data: Full disk-under-compression simulation</li> <li>Stress Distribution: Expected patterns and symmetries</li> <li>Parameter Validation: Input checking and error handling</li> </ul> <p>Key Features Tested: - Circular disk under diametral compression - Brazilian disk test geometry - Theoretical stress field validation - Noise addition for realistic data - Multiple wavelengths and polarization states</p>"},{"location":"testing/#image-processing-and-io-test_image_iopy","title":"Image Processing and I/O (<code>test_image_io.py</code>)","text":"<p>Tests for image processing functions:</p> <ul> <li>Retardance: Array input handling</li> <li>Principal Angle: Special cases (pure shear, no shear)</li> <li>Mueller Matrix: Identity and symmetry properties</li> <li>Zero Stress: Degenerate cases</li> <li>Extreme Values: Numerical stability</li> <li>File I/O: Loading and saving results</li> <li>Configuration: JSON/JSON5 parameter files</li> </ul> <p>Key Features Tested: - Vectorized operations on arrays - Edge case handling (zero, inf, nan) - File format support - Error handling for missing/invalid files</p>"},{"location":"testing/#running-tests","title":"Running Tests","text":""},{"location":"testing/#basic-usage","title":"Basic Usage","text":"<pre><code># Run all tests\npytest\n\n# Run specific test file\npytest tests/test_stokes_solver_pytest.py\n\n# Run specific test class\npytest tests/test_stokes_solver_pytest.py::TestStokesComponents\n\n# Run specific test function\npytest tests/test_stokes_solver_pytest.py::TestStokesComponents::test_compute_stokes_components\n\n# Verbose output\npytest -v\n\n# Show print statements\npytest -s\n</code></pre>"},{"location":"testing/#coverage-analysis","title":"Coverage Analysis","text":"<pre><code># Generate coverage report\npytest --cov=photoelastimetry\n\n# Generate HTML coverage report\npytest --cov=photoelastimetry --cov-report=html\n\n# Generate XML coverage report (for CI)\npytest --cov=photoelastimetry --cov-report=xml\n\n# Show missing lines\npytest --cov=photoelastimetry --cov-report=term-missing\n</code></pre>"},{"location":"testing/#test-selection","title":"Test Selection","text":"<pre><code># Run only fast tests (exclude slow)\npytest -m \"not slow\"\n\n# Run only unit tests\npytest -m unit\n\n# Run only integration tests\npytest -m integration\n\n# Run tests matching pattern\npytest -k \"stokes\"\n\n# Run tests in parallel (requires pytest-xdist)\npytest -n auto\n</code></pre>"},{"location":"testing/#test-fixtures","title":"Test Fixtures","text":"<p>Common fixtures used across tests:</p> <ul> <li><code>test_parameters</code>: Standard material and measurement parameters</li> <li>Wavelengths (R, G, B)</li> <li>Stress-optic coefficients</li> <li>Sample thickness</li> <li>Solid fraction</li> <li> <p>Incident polarization state</p> </li> <li> <p><code>sample_stress</code>: Representative stress tensor components</p> </li> <li> <p>\u03c3_xx, \u03c3_yy, \u03c3_xy values</p> </li> <li> <p><code>sample_intensities</code>: Four-step polarimetry measurements</p> </li> <li> <p>I_0\u00b0, I_45\u00b0, I_90\u00b0, I_135\u00b0</p> </li> <li> <p><code>sample_grid</code>: Grid parameters for field-based tests</p> </li> <li> <p>Height, width, shape</p> </li> <li> <p><code>temp_directory</code>: Temporary directory for I/O tests</p> </li> </ul>"},{"location":"testing/#continuous-integration","title":"Continuous Integration","text":"<p>Tests run automatically on GitHub Actions for:</p> <ul> <li>Python versions: 3.9, 3.10, 3.11, 3.12</li> <li>On events: Push to main/develop, pull requests</li> <li>Checks:</li> <li>All tests pass</li> <li>Code formatting (black)</li> <li>Linting (flake8)</li> <li>Minimum 70% coverage</li> </ul> <p>Coverage reports are automatically uploaded to Codecov.</p>"},{"location":"testing/#writing-new-tests","title":"Writing New Tests","text":"<p>When adding new functionality, include tests that cover:</p> <ol> <li>Happy path: Normal, expected usage</li> <li>Edge cases: Boundary conditions, empty inputs, zeros</li> <li>Error handling: Invalid inputs, exceptions</li> <li>Integration: How the feature works with existing code</li> <li>Performance: For computationally intensive operations (mark as <code>@pytest.mark.slow</code>)</li> </ol> <p>Example test structure:</p> <pre><code>import pytest\nimport numpy as np\n\n@pytest.fixture\ndef sample_data():\n    return {'x': 1.0, 'y': 2.0}\n\nclass TestNewFeature:\n    \"\"\"Tests for new feature X.\"\"\"\n\n    def test_basic_functionality(self, sample_data):\n        \"\"\"Test normal operation.\"\"\"\n        result = new_function(**sample_data)\n        assert result &gt; 0\n        assert np.isfinite(result)\n\n    def test_edge_case_zero(self):\n        \"\"\"Test with zero input.\"\"\"\n        result = new_function(x=0, y=0)\n        assert result == 0\n\n    def test_invalid_input(self):\n        \"\"\"Test error handling.\"\"\"\n        with pytest.raises(ValueError):\n            new_function(x=-1, y=2)\n</code></pre>"},{"location":"testing/#coverage-goals","title":"Coverage Goals","text":"<p>Target coverage by module:</p> <ul> <li>Core solvers: &gt;80% (stokes_solver, intensity_solver, equilibrium_solver)</li> <li>Utilities: &gt;70% (image, io, plotting)</li> <li>Applications: &gt;60% (disk, main)</li> <li>Overall: &gt;70%</li> </ul>"},{"location":"testing/#known-test-limitations","title":"Known Test Limitations","text":"<p>Some aspects are not fully tested:</p> <ul> <li>GUI/interactive features</li> <li>Hardware-specific I/O (camera interfaces)</li> <li>Large-scale performance tests</li> <li>Full integration with external dependencies</li> </ul> <p>These are acceptable given the scientific computing focus and availability of manual validation procedures.</p>"},{"location":"testing/#test-maintenance","title":"Test Maintenance","text":"<ul> <li>Review and update tests when APIs change</li> <li>Add tests for bug fixes (regression tests)</li> <li>Remove or mark obsolete tests</li> <li>Keep test execution time reasonable (&lt;5 minutes for full suite)</li> <li>Update this documentation when test structure changes</li> </ul>"},{"location":"user-guide/","title":"User Guide","text":""},{"location":"user-guide/#overview","title":"Overview","text":"<p>Photoelastimetry is a package for processing polarised images to measure stress in granular media using photoelastic techniques. This guide covers the main workflows and configuration options.</p>"},{"location":"user-guide/#command-line-tools","title":"Command Line Tools","text":""},{"location":"user-guide/#image-to-stress","title":"image-to-stress","text":"<p>Converts photoelastic images to stress maps using the stress-optic law and polarisation analysis.</p> <pre><code>image-to-stress &lt;json_filename&gt; [--output OUTPUT]\n</code></pre> <p>Arguments:</p> <ul> <li><code>json_filename</code>: Path to the JSON5 parameter file containing configuration (required)</li> <li><code>--output</code>: Path to save the output stress map image (optional)</li> </ul> <p>Example:</p> <pre><code>image-to-stress params.json5 --output stress_map.png\n</code></pre> <p>JSON5 Parameters:</p> <p>The JSON5 parameter file should contain:</p> <ul> <li><code>folderName</code>: Path to folder containing raw photoelastic images</li> <li><code>C</code>: Stress-optic coefficient in 1/Pa</li> <li><code>thickness</code>: Sample thickness in meters</li> <li><code>wavelengths</code>: List of wavelengths in nanometers</li> <li><code>S_i_hat</code>: Incoming normalized Stokes vector [S1_hat, S2_hat, S3_hat] representing polarization state</li> <li><code>crop</code> (optional): Crop region as [y1, y2, x1, x2]</li> <li><code>debug</code> (optional): If true, display all channels for debugging</li> </ul> <p>Example parameter file:</p> <pre><code>{\n  \"folderName\": \"./images/experiment1\",\n  \"C\": 5e-11,\n  \"thickness\": 0.005,\n  \"wavelengths\": [450, 550, 650],\n  \"S_i_hat\": [1.0, 0.0, 0.0],\n  \"crop\": [100, 900, 100, 900],\n  \"debug\": false\n}\n</code></pre>"},{"location":"user-guide/#stress-to-image","title":"stress-to-image","text":"<p>Converts stress field data to photoelastic fringe pattern images. This is useful for validating stress field calculations or generating synthetic training data.</p> <pre><code>stress-to-image &lt;json_filename&gt;\n</code></pre> <p>Arguments:</p> <ul> <li><code>json_filename</code>: Path to the JSON5 parameter file containing configuration (required)</li> </ul> <p>Example:</p> <pre><code>stress-to-image params.json5\n</code></pre> <p>JSON5 Parameters:</p> <p>The JSON5 parameter file should contain:</p> <ul> <li><code>p_filename</code>: Path to the photoelastimetry parameter file</li> <li><code>stress_filename</code>: Path to the stress field data file</li> <li><code>t</code>: Thickness of the photoelastic material</li> <li><code>lambda_light</code>: Wavelength of light used in the experiment</li> <li><code>C</code>: Stress-optic coefficient of the material</li> <li><code>scattering</code> (optional): Gaussian filter sigma for scattering simulation</li> <li><code>output_filename</code> (optional): Path for the output image (default: \"output.png\")</li> </ul>"},{"location":"user-guide/#demosaic-raw","title":"demosaic-raw","text":"<p>De-mosaics a raw polarimetric image from a camera with a 4x4 superpixel pattern into separate colour and polarisation channels.</p> <pre><code>demosaic-raw &lt;input_file&gt; [OPTIONS]\n</code></pre> <p>Arguments:</p> <ul> <li><code>input_file</code>: Path to the raw image file, or directory when using <code>--all</code> (required)</li> <li><code>--width</code>: Image width in pixels (default: 4096)</li> <li><code>--height</code>: Image height in pixels (default: 3000)</li> <li><code>--dtype</code>: Data type, either 'uint8' or 'uint16' (auto-detected if not specified)</li> <li><code>--output-prefix</code>: Prefix for output files (default: input filename without extension)</li> <li><code>--format</code>: Output format, either 'tiff' or 'png' (default: 'tiff')</li> <li><code>--all</code>: Recursively process all .raw files in the input directory and subdirectories</li> </ul> <p>Examples:</p> <pre><code># Save as a single TIFF stack\ndemosaic-raw image.raw --width 2448 --height 2048 --dtype uint16 --format tiff\n\n# Save as four separate PNG files (one per polarisation angle)\ndemosaic-raw image.raw --width 2448 --height 2048 --format png --output-prefix output\n\n# Process all raw files in a directory recursively\ndemosaic-raw images/ --format png --all\n</code></pre> <p>Output formats:</p> <ul> <li><code>tiff</code>: Creates a single TIFF file with shape [H/4, W/4, 4, 4] containing all colour channels (R, G1, G2, B) and polarisation angles (0\u00b0, 45\u00b0, 90\u00b0, 135\u00b0)</li> <li><code>png</code>: Creates 4 PNG files (one per polarisation angle), each containing all colour channels as a composite image</li> </ul>"},{"location":"user-guide/#stress-analysis-methods","title":"Stress Analysis Methods","text":"<p>The package provides three complementary approaches for stress field recovery:</p>"},{"location":"user-guide/#stokes-based-solver","title":"Stokes-based Solver","text":"<p>Uses normalized Stokes components for pixel-wise stress inversion. This is the primary method for most applications.</p> <ul> <li>Best for: Standard photoelastic analysis</li> <li>Module: <code>photoelastimetry.solver.stokes_solver</code></li> </ul>"},{"location":"user-guide/#intensity-based-solver","title":"Intensity-based Solver","text":"<p>Works directly with raw polarization intensities for pixel-wise inversion.</p> <ul> <li>Best for: When raw intensities are more reliable than Stokes parameters</li> <li>Module: <code>photoelastimetry.solver.intensity_solver</code></li> </ul>"},{"location":"user-guide/#equilibrium-solver","title":"Equilibrium Solver","text":"<p>Global inversion that enforces mechanical equilibrium constraints using an Airy stress function.</p> <ul> <li>Best for: Cases where mechanical equilibrium is important</li> <li>Module: <code>photoelastimetry.solver.equilibrium_solver</code></li> </ul>"},{"location":"user-guide/#photoelastic-theory","title":"Photoelastic Theory","text":""},{"location":"user-guide/#stress-optic-law","title":"Stress-Optic Law","text":"<p>The fundamental relationship between stress and optical retardation:</p> <pre><code>\u03b4 = C \u00b7 t \u00b7 (\u03c3\u2081 - \u03c3\u2082)\n</code></pre> <p>Where: - \u03b4 is the optical retardation - C is the stress-optic coefficient - t is the specimen thickness - \u03c3\u2081, \u03c3\u2082 are the principal stresses</p>"},{"location":"user-guide/#mueller-matrix-formalism","title":"Mueller Matrix Formalism","text":"<p>The package uses Mueller matrix calculus to model light propagation through the photoelastic sample and optical elements.</p>"},{"location":"user-guide/#tips-and-best-practices","title":"Tips and Best Practices","text":"<ol> <li>Calibration: Always calibrate the stress-optic coefficient (C) for your specific material</li> <li>Image Quality: Use high-quality, well-exposed images with minimal noise</li> <li>Wavelength Selection: Multiple wavelengths improve stress field resolution</li> <li>Cropping: Crop images to regions of interest to reduce computation time</li> <li>Validation: Compare results from different solver methods when possible</li> </ol>"},{"location":"reference/","title":"API Reference","text":"<p>This section provides detailed documentation for all modules, classes, and functions in the photoelastimetry package.</p>"},{"location":"reference/#core-modules","title":"Core Modules","text":"<ul> <li>disk - Elastic disk solution and photoelastic simulation</li> <li>image - Image processing and Mueller matrix operations</li> <li>io - Input/output operations for images and data</li> <li>main - Command-line interface entry points</li> <li>plotting - Visualization utilities and colormaps</li> </ul>"},{"location":"reference/#solver-modules","title":"Solver Modules","text":"<p>The solver subpackage provides three complementary approaches for stress field recovery:</p> <ul> <li>solver - Main solver module with high-level API</li> <li>solver.stokes_solver - Stokes-based pixel-wise inversion</li> <li>solver.intensity_solver - Intensity-based pixel-wise inversion</li> <li>solver.equilibrium_solver - Global equilibrium-based inversion</li> </ul>"},{"location":"reference/#quick-links","title":"Quick Links","text":""},{"location":"reference/#most-common-functions","title":"Most Common Functions","text":"<p>Stress Analysis: - <code>solver.recover_stress_map_stokes()</code> - Primary method for stress recovery - <code>solver.compute_stokes_components()</code> - Compute Stokes parameters - <code>solver.compute_normalized_stokes()</code> - Normalize Stokes components</p> <p>Image Processing: - <code>image.compute_retardance()</code> - Calculate optical retardance - <code>image.compute_principal_angle()</code> - Calculate principal stress angle - <code>image.mueller_matrix()</code> - Generate Mueller matrices</p> <p>Simulation: - <code>disk.simulate_four_step_polarimetry()</code> - Simulate photoelastic response</p> <p>See individual module pages for complete documentation.</p>"},{"location":"reference/disk/","title":"disk","text":"<p>Elastic disk solution and photoelastic simulation.</p> <p>This module provides functions for simulating the photoelastic response of an elastic disk under compression, including analytical stress solutions and Mueller matrix-based polarimetry simulation.</p>"},{"location":"reference/disk/#photoelastimetry.disk","title":"<code>disk</code>","text":""},{"location":"reference/disk/#photoelastimetry.disk-functions","title":"Functions","text":""},{"location":"reference/disk/#photoelastimetry.disk.simulate_four_step_polarimetry","title":"<code>simulate_four_step_polarimetry(sigma_xx, sigma_yy, sigma_xy, C, nu, L, wavelength, S_i_hat, I0=1.0)</code>","text":"<p>Simulate four-step polarimetry using Mueller matrix formalism.</p> <p>This is consistent with the approach in local.py and uses proper Mueller matrix calculus to predict intensities from stress tensor.</p> <p>Parameters:</p> Name Type Description Default <code>sigma_xx</code> <code>float or array - like</code> <p>Normal stress component in x direction (Pa).</p> required <code>sigma_yy</code> <code>float or array - like</code> <p>Normal stress component in y direction (Pa).</p> required <code>sigma_xy</code> <code>float or array - like</code> <p>Shear stress component (Pa).</p> required <code>C</code> <code>float</code> <p>Stress-optic coefficient (1/Pa).</p> required <code>nu</code> <code>float</code> <p>Solid fraction (use 1.0 for solid samples).</p> required <code>L</code> <code>float</code> <p>Sample thickness (m).</p> required <code>wavelength</code> <code>float</code> <p>Wavelength of light (m).</p> required <code>S_i_hat</code> <code>array - like</code> <p>Incoming normalized Stokes vector [S1_hat, S2_hat] or [S1_hat, S2_hat, S3_hat].</p> required <code>I0</code> <code>float</code> <p>Incident light intensity (default: 1.0).</p> <code>1.0</code> <p>Returns:</p> Type Description <code>Four intensity images for analyzer angles 0\u00b0, 45\u00b0, 90\u00b0, 135\u00b0</code> Source code in <code>photoelastimetry/disk.py</code> <pre><code>def simulate_four_step_polarimetry(sigma_xx, sigma_yy, sigma_xy, C, nu, L, wavelength, S_i_hat, I0=1.0):\n    \"\"\"\n    Simulate four-step polarimetry using Mueller matrix formalism.\n\n    This is consistent with the approach in local.py and uses proper Mueller matrix\n    calculus to predict intensities from stress tensor.\n\n    Parameters\n    ----------\n    sigma_xx : float or array-like\n        Normal stress component in x direction (Pa).\n    sigma_yy : float or array-like\n        Normal stress component in y direction (Pa).\n    sigma_xy : float or array-like\n        Shear stress component (Pa).\n    C : float\n        Stress-optic coefficient (1/Pa).\n    nu : float\n        Solid fraction (use 1.0 for solid samples).\n    L : float\n        Sample thickness (m).\n    wavelength : float\n        Wavelength of light (m).\n    S_i_hat : array-like\n        Incoming normalized Stokes vector [S1_hat, S2_hat] or [S1_hat, S2_hat, S3_hat].\n    I0 : float\n        Incident light intensity (default: 1.0).\n\n    Returns\n    -------\n    Four intensity images for analyzer angles 0\u00b0, 45\u00b0, 90\u00b0, 135\u00b0\n    \"\"\"\n    # Compute retardance and principal angle from stress tensor\n    theta = local.compute_principal_angle(sigma_xx, sigma_yy, sigma_xy)\n    delta = local.compute_retardance(sigma_xx, sigma_yy, sigma_xy, C, nu, L, wavelength)\n\n    # Get Mueller matrix\n    M = local.mueller_matrix(theta, delta)\n\n    # Create full incoming Stokes vector\n    S_i_hat = np.asarray(S_i_hat)\n    if len(S_i_hat) == 2:\n        # Backward compatibility: assume S3 = 0 (no circular polarization)\n        S_i_full = np.array([1.0, S_i_hat[0], S_i_hat[1], 0.0])\n    elif len(S_i_hat) == 3:\n        # Use provided circular component\n        S_i_full = np.array([1.0, S_i_hat[0], S_i_hat[1], S_i_hat[2]])\n    else:\n        raise ValueError(f\"S_i_hat must have 2 or 3 elements, got {len(S_i_hat)}\")\n\n    # Apply Mueller matrix to get output Stokes vector\n    if M.ndim == 2:\n        # Single pixel case\n        S_out = M @ S_i_full\n    else:\n        # Array case - need to handle broadcasting\n        S_out = np.einsum(\"...ij,j-&gt;...i\", M, S_i_full)\n\n    # Extract S0, S1, S2 from output\n    S0_out = S_out[..., 0] if S_out.ndim &gt; 1 else S_out[0]\n    S1_out = S_out[..., 1] if S_out.ndim &gt; 1 else S_out[1]\n    S2_out = S_out[..., 2] if S_out.ndim &gt; 1 else S_out[2]\n\n    # Compute intensities for four analyzer angles\n    # I(\u03b1) = (S0 + S1*cos(2\u03b1) + S2*sin(2\u03b1)) / 2\n    I0_pol = I0 * (S0_out + S1_out) / 2  # \u03b1 = 0\u00b0\n    I45_pol = I0 * (S0_out + S2_out) / 2  # \u03b1 = 45\u00b0\n    I90_pol = I0 * (S0_out - S1_out) / 2  # \u03b1 = 90\u00b0\n    I135_pol = I0 * (S0_out - S2_out) / 2  # \u03b1 = 135\u00b0\n\n    return I0_pol, I45_pol, I90_pol, I135_pol\n</code></pre>"},{"location":"reference/disk/#photoelastimetry.disk.diametrical_stress_cartesian","title":"<code>diametrical_stress_cartesian(X, Y, P, R)</code>","text":"<p>Exact Brazil test solution from ISRM standards and Jaeger &amp; Cook P: total load (force per unit thickness) R: disk radius</p> <p>Key validation: At center (0,0): - sigma_x = 2P/(piR) (tensile) - sigma_y = -6P/(piR) (compressive) - tau_xy = 0</p> Source code in <code>photoelastimetry/disk.py</code> <pre><code>def diametrical_stress_cartesian(X, Y, P, R):\n    \"\"\"\n    Exact Brazil test solution from ISRM standards and Jaeger &amp; Cook\n    P: total load (force per unit thickness)\n    R: disk radius\n\n    Key validation: At center (0,0):\n    - sigma_x = 2P/(pi*R) (tensile)\n    - sigma_y = -6P/(pi*R) (compressive)\n    - tau_xy = 0\n    \"\"\"\n\n    X_safe = X.copy()\n    Y_safe = Y.copy()\n\n    # Small offset to avoid singularities at origin\n    origin_mask = (X**2 + Y**2) &lt; (0.001 * R) ** 2\n    X_safe = np.where(origin_mask, 0.001 * R, X_safe)\n    Y_safe = np.where(origin_mask, 0.001 * R, Y_safe)\n\n    # Distance from load points\n    r1 = np.sqrt(X_safe**2 + (Y_safe - R) ** 2)  # from (0, R)\n    r2 = np.sqrt(X_safe**2 + (Y_safe + R) ** 2)  # from (0, -R)\n\n    # Angles from load points\n    theta1 = np.arctan2(X_safe, Y_safe - R)\n    theta2 = np.arctan2(X_safe, Y_safe + R)\n\n    sigma_xx = (\n        -(2 * P / np.pi)\n        * (np.cos(theta1) ** 2 * (Y_safe - R) / (r1**2) - np.cos(theta2) ** 2 * (Y_safe + R) / (r2**2))\n        / R\n    )\n\n    sigma_yy = (\n        -(2 * P / np.pi)\n        * (np.sin(theta1) ** 2 * (Y_safe - R) / (r1**2) - np.sin(theta2) ** 2 * (Y_safe + R) / (r2**2))\n        / R\n    )\n\n    tau_xy = (\n        -(2 * P / np.pi)\n        * (\n            np.sin(theta1) * np.cos(theta1) * (Y_safe - R) / (r1**2)\n            - np.sin(theta2) * np.cos(theta2) * (Y_safe + R) / (r2**2)\n        )\n        / R\n    )\n\n    return sigma_xx, sigma_yy, tau_xy\n</code></pre>"},{"location":"reference/disk/#photoelastimetry.disk.generate_synthetic_brazil_test","title":"<code>generate_synthetic_brazil_test(X, Y, P, R, S_i_hat, mask, wavelengths_nm, thickness, C, polarisation_efficiency)</code>","text":"<p>Generate synthetic Brazil test data for validation This function creates a synthetic dataset based on the analytical solution and saves it in a format suitable for testing.</p> Source code in <code>photoelastimetry/disk.py</code> <pre><code>def generate_synthetic_brazil_test(\n    X, Y, P, R, S_i_hat, mask, wavelengths_nm, thickness, C, polarisation_efficiency\n):\n    \"\"\"\n    Generate synthetic Brazil test data for validation\n    This function creates a synthetic dataset based on the analytical solution\n    and saves it in a format suitable for testing.\n    \"\"\"\n\n    # Get stress components directly\n    sigma_xx, sigma_yy, tau_xy = diametrical_stress_cartesian(X, Y, P, R)\n\n    # Mask outside the disk\n    sigma_xx[~mask] = np.nan\n    sigma_yy[~mask] = np.nan\n    tau_xy[~mask] = np.nan\n\n    # Principal stress difference and angle\n    sigma_avg = 0.5 * (sigma_xx + sigma_yy)\n    R_mohr = np.sqrt(((sigma_xx - sigma_yy) / 2) ** 2 + tau_xy**2)\n    sigma1 = sigma_avg + R_mohr\n    sigma2 = sigma_avg - R_mohr\n    principal_diff = sigma1 - sigma2\n    theta_p = 0.5 * np.arctan2(2 * tau_xy, sigma_xx - sigma_yy)\n\n    # Mask again\n    principal_diff[~mask] = np.nan\n    theta_p[~mask] = np.nan\n\n    height, width = sigma_xx.shape\n\n    synthetic_images = np.empty((height, width, 3, 4))  # RGB, 4 polarizer angles\n\n    # Use incoming light fully S1 polarized (standard setup)\n    # S_i_hat = np.array([0.0, 0.0, 1.0])\n    nu = 1.0  # Solid sample\n\n    for i, lambda_light in tqdm(enumerate(wavelengths_nm)):\n        # Generate four-step polarimetry images using Mueller matrix approach\n        I0_pol, I45_pol, I90_pol, I135_pol = simulate_four_step_polarimetry(\n            sigma_xx, sigma_yy, tau_xy, C[i], nu, thickness, lambda_light, S_i_hat\n        )\n\n        synthetic_images[:, :, i, 0] = I0_pol\n        synthetic_images[:, :, i, 1] = I45_pol\n        synthetic_images[:, :, i, 2] = I90_pol\n        synthetic_images[:, :, i, 3] = I135_pol\n\n    return (\n        synthetic_images,\n        principal_diff,\n        theta_p,\n        sigma_xx,\n        sigma_yy,\n        tau_xy,\n    )\n</code></pre>"},{"location":"reference/equilibrium_solver/","title":"solver.equilibrium_solver","text":"<p>Global equilibrium-based stress inversion.</p> <p>This module implements a global stress field recovery method that enforces mechanical equilibrium constraints using an Airy stress function representation. This approach ensures the recovered stress field satisfies equilibrium equations.</p>"},{"location":"reference/equilibrium_solver/#key-functions","title":"Key Functions","text":"<ul> <li><code>build_finite_difference_operators()</code> - Construct finite difference matrices</li> <li><code>airy_to_stress()</code> - Convert Airy function to stress components</li> <li><code>recover_stress_field_global()</code> - Main function for equilibrium-based recovery</li> <li><code>compare_local_vs_global()</code> - Compare pixel-wise vs equilibrium methods</li> </ul>"},{"location":"reference/equilibrium_solver/#photoelastimetry.solver.equilibrium_solver","title":"<code>equilibrium_solver</code>","text":"<p>Global stress measurement using Airy stress function.</p> <p>This module implements a global inversion approach that solves for an Airy stress function across the entire domain simultaneously. Unlike the local pixel-by-pixel method, this approach:</p> <ol> <li>Ensures mechanical equilibrium by construction (through Airy stress function)</li> <li>Enforces smoothness globally via regularization</li> <li>Avoids local minima by solving a single global optimization problem</li> <li>Provides more stable results by incorporating spatial coupling</li> </ol> <p>The Airy stress function \u03c6(x,y) relates to stresses via:     \u03c3_xx = \u2202\u00b2\u03c6/\u2202y\u00b2     \u03c3_yy = \u2202\u00b2\u03c6/\u2202x\u00b2     \u03c3_xy = -\u2202\u00b2\u03c6/\u2202x\u2202y</p> <p>These automatically satisfy equilibrium: \u2202\u03c3_xx/\u2202x + \u2202\u03c3_xy/\u2202y = 0 and \u2202\u03c3_xy/\u2202x + \u2202\u03c3_yy/\u2202y = 0.</p>"},{"location":"reference/equilibrium_solver/#photoelastimetry.solver.equilibrium_solver-functions","title":"Functions","text":""},{"location":"reference/equilibrium_solver/#photoelastimetry.solver.equilibrium_solver.build_finite_difference_operators","title":"<code>build_finite_difference_operators(nx, ny, dx=1.0, dy=1.0)</code>","text":"<p>Build sparse finite difference operators for computing derivatives.</p> <p>Uses central differences for interior points and forward/backward differences at boundaries.</p> <p>Parameters:</p> Name Type Description Default <code>nx</code> <code>int</code> <p>Number of grid points in x direction.</p> required <code>ny</code> <code>int</code> <p>Number of grid points in y direction.</p> required <code>dx</code> <code>float</code> <p>Grid spacing in x direction (default: 1.0).</p> <code>1.0</code> <code>dy</code> <code>float</code> <p>Grid spacing in y direction (default: 1.0).</p> <code>1.0</code> <p>Returns:</p> Name Type Description <code>D2x</code> <code>scipy.sparse matrix</code> <p>Second derivative operator in x direction (\u2202\u00b2/\u2202x\u00b2).</p> <code>D2y</code> <code>scipy.sparse matrix</code> <p>Second derivative operator in y direction (\u2202\u00b2/\u2202y\u00b2).</p> <code>Dxy</code> <code>scipy.sparse matrix</code> <p>Mixed derivative operator (\u2202\u00b2/\u2202x\u2202y).</p> <code>L</code> <code>scipy.sparse matrix</code> <p>Laplacian operator (\u2207\u00b2).</p> Source code in <code>photoelastimetry/solver/equilibrium_solver.py</code> <pre><code>def build_finite_difference_operators(nx, ny, dx=1.0, dy=1.0):\n    \"\"\"\n    Build sparse finite difference operators for computing derivatives.\n\n    Uses central differences for interior points and forward/backward\n    differences at boundaries.\n\n    Parameters\n    ----------\n    nx : int\n        Number of grid points in x direction.\n    ny : int\n        Number of grid points in y direction.\n    dx : float, optional\n        Grid spacing in x direction (default: 1.0).\n    dy : float, optional\n        Grid spacing in y direction (default: 1.0).\n\n    Returns\n    -------\n    D2x : scipy.sparse matrix\n        Second derivative operator in x direction (\u2202\u00b2/\u2202x\u00b2).\n    D2y : scipy.sparse matrix\n        Second derivative operator in y direction (\u2202\u00b2/\u2202y\u00b2).\n    Dxy : scipy.sparse matrix\n        Mixed derivative operator (\u2202\u00b2/\u2202x\u2202y).\n    L : scipy.sparse matrix\n        Laplacian operator (\u2207\u00b2).\n    \"\"\"\n    from scipy.sparse import diags\n    from scipy.sparse import eye as speye\n    from scipy.sparse import kron\n\n    # 1D second derivative operator (central differences)\n    # [1, -2, 1] / dx^2\n    diag_1d = np.array([1.0, -2.0, 1.0])\n    offsets_1d = np.array([-1, 0, 1])\n\n    # Build 1D operators\n    D2_1d_x = diags(diag_1d, offsets_1d, shape=(nx, nx)) / dx**2\n    D2_1d_y = diags(diag_1d, offsets_1d, shape=(ny, ny)) / dy**2\n\n    # 2D operators using Kronecker products\n    # For a field organized as [\u03c6(0,0), \u03c6(1,0), ..., \u03c6(nx-1,0), \u03c6(0,1), ...]\n    I_x = speye(nx)\n    I_y = speye(ny)\n\n    # \u2202\u00b2/\u2202x\u00b2 operator\n    D2x = kron(I_y, D2_1d_x)\n\n    # \u2202\u00b2/\u2202y\u00b2 operator\n    D2y = kron(D2_1d_y, I_x)\n\n    # Mixed derivative \u2202\u00b2/\u2202x\u2202y\n    # First derivative operators\n    diag_d1 = np.array([-0.5, 0.0, 0.5])\n    offsets_d1 = np.array([-1, 0, 1])\n\n    Dx_1d = diags(diag_d1, offsets_d1, shape=(nx, nx)) / dx\n    Dy_1d = diags(diag_d1, offsets_d1, shape=(ny, ny)) / dy\n\n    Dx = kron(I_y, Dx_1d)\n    Dy = kron(Dy_1d, I_x)\n\n    # Mixed derivative: \u2202/\u2202x(\u2202/\u2202y)\n    Dxy = Dx @ Dy\n\n    # Laplacian (for regularization)\n    L = D2x + D2y\n\n    return D2x, D2y, Dxy, L\n</code></pre>"},{"location":"reference/equilibrium_solver/#photoelastimetry.solver.equilibrium_solver.airy_to_stress","title":"<code>airy_to_stress(phi, D2x, D2y, Dxy)</code>","text":"<p>Convert Airy stress function to stress components.</p> <p>Parameters:</p> Name Type Description Default <code>phi</code> <code>ndarray</code> <p>Airy stress function values on grid (flattened or 2D).</p> required <code>D2x</code> <code>scipy.sparse matrix</code> <p>Second derivative operator in x direction.</p> required <code>D2y</code> <code>scipy.sparse matrix</code> <p>Second derivative operator in y direction.</p> required <code>Dxy</code> <code>scipy.sparse matrix</code> <p>Mixed derivative operator.</p> required <p>Returns:</p> Name Type Description <code>sigma_xx</code> <code>ndarray</code> <p>Normal stress in x direction (same shape as phi).</p> <code>sigma_yy</code> <code>ndarray</code> <p>Normal stress in y direction (same shape as phi).</p> <code>sigma_xy</code> <code>ndarray</code> <p>Shear stress (same shape as phi).</p> Source code in <code>photoelastimetry/solver/equilibrium_solver.py</code> <pre><code>def airy_to_stress(phi, D2x, D2y, Dxy):\n    \"\"\"\n    Convert Airy stress function to stress components.\n\n    Parameters\n    ----------\n    phi : ndarray\n        Airy stress function values on grid (flattened or 2D).\n    D2x : scipy.sparse matrix\n        Second derivative operator in x direction.\n    D2y : scipy.sparse matrix\n        Second derivative operator in y direction.\n    Dxy : scipy.sparse matrix\n        Mixed derivative operator.\n\n    Returns\n    -------\n    sigma_xx : ndarray\n        Normal stress in x direction (same shape as phi).\n    sigma_yy : ndarray\n        Normal stress in y direction (same shape as phi).\n    sigma_xy : ndarray\n        Shear stress (same shape as phi).\n    \"\"\"\n    phi_flat = phi.flatten()\n\n    # \u03c3_xx = \u2202\u00b2\u03c6/\u2202y\u00b2\n    sigma_xx = D2y @ phi_flat\n\n    # \u03c3_yy = \u2202\u00b2\u03c6/\u2202x\u00b2\n    sigma_yy = D2x @ phi_flat\n\n    # \u03c3_xy = -\u2202\u00b2\u03c6/\u2202x\u2202y\n    sigma_xy = -Dxy @ phi_flat\n\n    return sigma_xx, sigma_yy, sigma_xy\n</code></pre>"},{"location":"reference/equilibrium_solver/#photoelastimetry.solver.equilibrium_solver.compute_global_residual","title":"<code>compute_global_residual(phi, image_stack, wavelengths, C_values, nu, L, S_i_hat, D2x, D2y, Dxy, mask, lambda_smooth=1.0, lambda_biharmonic=0.0)</code>","text":"<p>Compute global residual for Airy stress function optimization.</p> <p>This function computes the misfit between measured and predicted Stokes parameters across all pixels and wavelengths, plus regularization terms.</p> <p>Parameters:</p> Name Type Description Default <code>phi</code> <code>ndarray</code> <p>Airy stress function values (flattened).</p> required <code>image_stack</code> <code>ndarray</code> <p>Image stack [H, W, 3, 4] with RGB channels and 4 polarization angles.</p> required <code>wavelengths</code> <code>array - like</code> <p>Wavelengths for RGB channels (m).</p> required <code>C_values</code> <code>array - like</code> <p>Stress-optic coefficients for RGB channels (1/Pa).</p> required <code>nu</code> <code>float or ndarray</code> <p>Solid fraction (use 1.0 for solid samples).</p> required <code>L</code> <code>float</code> <p>Sample thickness (m).</p> required <code>S_i_hat</code> <code>array - like</code> <p>Incoming normalized Stokes vector [S1_hat, S2_hat] or [S1_hat, S2_hat, S3_hat].</p> required <code>D2x</code> <code>scipy.sparse matrix</code> <p>Finite difference operators.</p> required <code>D2y</code> <code>scipy.sparse matrix</code> <p>Finite difference operators.</p> required <code>Dxy</code> <code>scipy.sparse matrix</code> <p>Finite difference operators.</p> required <code>mask</code> <code>ndarray</code> <p>Boolean mask indicating valid pixels (H, W).</p> required <code>lambda_smooth</code> <code>float</code> <p>Regularization weight for Laplacian smoothing (default: 1.0).</p> <code>1.0</code> <code>lambda_biharmonic</code> <code>float</code> <p>Regularization weight for biharmonic smoothing (default: 0.0).</p> <code>0.0</code> <p>Returns:</p> Name Type Description <code>residual</code> <code>float</code> <p>Total residual including data misfit and regularization terms.</p> Source code in <code>photoelastimetry/solver/equilibrium_solver.py</code> <pre><code>def compute_global_residual(\n    phi,\n    image_stack,\n    wavelengths,\n    C_values,\n    nu,\n    L,\n    S_i_hat,\n    D2x,\n    D2y,\n    Dxy,\n    mask,\n    lambda_smooth=1.0,\n    lambda_biharmonic=0.0,\n):\n    \"\"\"\n    Compute global residual for Airy stress function optimization.\n\n    This function computes the misfit between measured and predicted Stokes\n    parameters across all pixels and wavelengths, plus regularization terms.\n\n    Parameters\n    ----------\n    phi : ndarray\n        Airy stress function values (flattened).\n    image_stack : ndarray\n        Image stack [H, W, 3, 4] with RGB channels and 4 polarization angles.\n    wavelengths : array-like\n        Wavelengths for RGB channels (m).\n    C_values : array-like\n        Stress-optic coefficients for RGB channels (1/Pa).\n    nu : float or ndarray\n        Solid fraction (use 1.0 for solid samples).\n    L : float\n        Sample thickness (m).\n    S_i_hat : array-like\n        Incoming normalized Stokes vector [S1_hat, S2_hat] or [S1_hat, S2_hat, S3_hat].\n    D2x, D2y, Dxy : scipy.sparse matrix\n        Finite difference operators.\n    mask : ndarray\n        Boolean mask indicating valid pixels (H, W).\n    lambda_smooth : float, optional\n        Regularization weight for Laplacian smoothing (default: 1.0).\n    lambda_biharmonic : float, optional\n        Regularization weight for biharmonic smoothing (default: 0.0).\n\n    Returns\n    -------\n    residual : float\n        Total residual including data misfit and regularization terms.\n    \"\"\"\n    H, W, _, _ = image_stack.shape\n\n    # Convert Airy function to stresses\n    sigma_xx, sigma_yy, sigma_xy = airy_to_stress(phi, D2x, D2y, Dxy)\n\n    # Reshape to 2D\n    sigma_xx = sigma_xx.reshape(H, W)\n    sigma_yy = sigma_yy.reshape(H, W)\n    sigma_xy = sigma_xy.reshape(H, W)\n\n    # Data misfit term\n    data_residual = 0.0\n    n_valid = 0\n\n    for i in range(H):\n        for j in range(W):\n            if not mask[i, j]:\n                continue\n\n            # Get measured Stokes components for this pixel\n            S_m_hat = np.zeros((3, 2))\n            valid_pixel = True\n\n            for c in range(3):  # RGB channels\n                I = image_stack[i, j, c, :]\n\n                if np.isnan(I).any():\n                    valid_pixel = False\n                    break\n\n                S0, S1, S2 = stokes_solver.compute_stokes_components(I[0], I[1], I[2], I[3])\n                S1_hat, S2_hat = stokes_solver.compute_normalized_stokes(S0, S1, S2)\n                S_m_hat[c, 0] = S1_hat\n                S_m_hat[c, 1] = S2_hat\n\n            if not valid_pixel:\n                continue\n\n            # Get solid fraction for this pixel\n            nu_pixel = nu if np.isscalar(nu) else nu[i, j]\n\n            # Predict Stokes components from stress\n            for c in range(3):\n                S_p_hat = stokes_solver.predict_stokes(\n                    sigma_xx[i, j],\n                    sigma_yy[i, j],\n                    sigma_xy[i, j],\n                    C_values[c],\n                    nu_pixel,\n                    L,\n                    wavelengths[c],\n                    S_i_hat,\n                )\n                diff = S_m_hat[c] - S_p_hat\n                data_residual += np.sum(diff**2)\n\n            n_valid += 1\n\n    # Normalize by number of valid pixels\n    if n_valid &gt; 0:\n        data_residual /= n_valid\n\n    # Smoothness regularization (Laplacian)\n    smoothness_residual = 0.0\n    if lambda_smooth &gt; 0:\n        # Build Laplacian operator\n        L_op = D2x + D2y\n        lap_phi = L_op @ phi\n        smoothness_residual = lambda_smooth * np.sum(lap_phi**2) / len(phi)\n\n    # Biharmonic regularization (\u2207\u2074\u03c6)\n    biharmonic_residual = 0.0\n    if lambda_biharmonic &gt; 0:\n        L_op = D2x + D2y\n        biharm_phi = L_op @ (L_op @ phi)\n        biharmonic_residual = lambda_biharmonic * np.sum(biharm_phi**2) / len(phi)\n\n    total_residual = data_residual + smoothness_residual + biharmonic_residual\n\n    return total_residual\n</code></pre>"},{"location":"reference/equilibrium_solver/#photoelastimetry.solver.equilibrium_solver.recover_stress_field_global","title":"<code>recover_stress_field_global(image_stack, wavelengths, C_values, nu, L, S_i_hat, mask=None, dx=1.0, dy=1.0, lambda_smooth=1e-06, lambda_biharmonic=0.0, initial_phi=None, maxiter=1000, method='L-BFGS-B', verbose=True)</code>","text":"<p>Recover stress field globally using Airy stress function.</p> <p>This is the main function for global stress field reconstruction. It sets up the optimization problem and solves for the Airy stress function that best fits the measured polarimetric data while enforcing smoothness.</p> <p>Parameters:</p> Name Type Description Default <code>image_stack</code> <code>ndarray</code> <p>Image stack [H, W, 3, 4] with RGB channels and 4 polarization angles.</p> required <code>wavelengths</code> <code>array - like</code> <p>Wavelengths for RGB channels (m).</p> required <code>C_values</code> <code>array - like</code> <p>Stress-optic coefficients for RGB channels (1/Pa).</p> required <code>nu</code> <code>float or ndarray</code> <p>Solid fraction (use 1.0 for solid samples).</p> required <code>L</code> <code>float</code> <p>Sample thickness (m).</p> required <code>S_i_hat</code> <code>array - like</code> <p>Incoming normalized Stokes vector [S1_hat, S2_hat, S3_hat].</p> required <code>mask</code> <code>ndarray</code> <p>Boolean mask indicating valid pixels [H, W]. If None, all pixels are used.</p> <code>None</code> <code>dx</code> <code>float</code> <p>Grid spacing in x direction (default: 1.0).</p> <code>1.0</code> <code>dy</code> <code>float</code> <p>Grid spacing in y direction (default: 1.0).</p> <code>1.0</code> <code>lambda_smooth</code> <code>float</code> <p>Regularization weight for Laplacian smoothing (default: 1e-6). Higher values enforce smoother solutions.</p> <code>1e-06</code> <code>lambda_biharmonic</code> <code>float</code> <p>Regularization weight for biharmonic smoothing (default: 0.0). Enforces even smoother solutions but can be expensive.</p> <code>0.0</code> <code>initial_phi</code> <code>ndarray</code> <p>Initial guess for Airy function [H, W]. If None, uses results from local solver as initialization.</p> <code>None</code> <code>maxiter</code> <code>int</code> <p>Maximum number of optimization iterations (default: 1000).</p> <code>1000</code> <code>method</code> <code>str</code> <p>Optimization method (default: 'L-BFGS-B'). Options: 'L-BFGS-B', 'CG', 'Newton-CG', 'trust-ncg'.</p> <code>'L-BFGS-B'</code> <code>verbose</code> <code>bool</code> <p>Print progress information (default: True).</p> <code>True</code> <p>Returns:</p> Name Type Description <code>phi</code> <code>ndarray</code> <p>Airy stress function [H, W].</p> <code>stress_field</code> <code>ndarray</code> <p>Stress components [H, W, 3] = [\u03c3_xx, \u03c3_yy, \u03c3_xy].</p> <code>result</code> <code>OptimizeResult</code> <p>Optimization result object.</p> Notes <p>The optimization minimizes:     E = E_data + \u03bb_smooth * E_smooth + \u03bb_biharm * E_biharm</p> <p>where: - E_data is the misfit between measured and predicted Stokes parameters - E_smooth is the Laplacian penalty (\u2207\u00b2\u03c6)\u00b2 - E_biharm is the biharmonic penalty (\u2207\u2074\u03c6)\u00b2</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; phi, stress, result = recover_stress_field_global(\n...     image_stack, wavelengths, C_values, nu=1.0, L=0.01,\n...     S_i_hat=np.array([1.0, 0.0, 0.0]), lambda_smooth=1e-5\n... )\n</code></pre> Source code in <code>photoelastimetry/solver/equilibrium_solver.py</code> <pre><code>def recover_stress_field_global(\n    image_stack,\n    wavelengths,\n    C_values,\n    nu,\n    L,\n    S_i_hat,\n    mask=None,\n    dx=1.0,\n    dy=1.0,\n    lambda_smooth=1e-6,\n    lambda_biharmonic=0.0,\n    initial_phi=None,\n    maxiter=1000,\n    method=\"L-BFGS-B\",\n    verbose=True,\n):\n    \"\"\"\n    Recover stress field globally using Airy stress function.\n\n    This is the main function for global stress field reconstruction. It sets up\n    the optimization problem and solves for the Airy stress function that best\n    fits the measured polarimetric data while enforcing smoothness.\n\n    Parameters\n    ----------\n    image_stack : ndarray\n        Image stack [H, W, 3, 4] with RGB channels and 4 polarization angles.\n    wavelengths : array-like\n        Wavelengths for RGB channels (m).\n    C_values : array-like\n        Stress-optic coefficients for RGB channels (1/Pa).\n    nu : float or ndarray\n        Solid fraction (use 1.0 for solid samples).\n    L : float\n        Sample thickness (m).\n    S_i_hat : array-like\n        Incoming normalized Stokes vector [S1_hat, S2_hat, S3_hat].\n    mask : ndarray, optional\n        Boolean mask indicating valid pixels [H, W]. If None, all pixels are used.\n    dx : float, optional\n        Grid spacing in x direction (default: 1.0).\n    dy : float, optional\n        Grid spacing in y direction (default: 1.0).\n    lambda_smooth : float, optional\n        Regularization weight for Laplacian smoothing (default: 1e-6).\n        Higher values enforce smoother solutions.\n    lambda_biharmonic : float, optional\n        Regularization weight for biharmonic smoothing (default: 0.0).\n        Enforces even smoother solutions but can be expensive.\n    initial_phi : ndarray, optional\n        Initial guess for Airy function [H, W]. If None, uses results from\n        local solver as initialization.\n    maxiter : int, optional\n        Maximum number of optimization iterations (default: 1000).\n    method : str, optional\n        Optimization method (default: 'L-BFGS-B'). Options: 'L-BFGS-B', 'CG',\n        'Newton-CG', 'trust-ncg'.\n    verbose : bool, optional\n        Print progress information (default: True).\n\n    Returns\n    -------\n    phi : ndarray\n        Airy stress function [H, W].\n    stress_field : ndarray\n        Stress components [H, W, 3] = [\u03c3_xx, \u03c3_yy, \u03c3_xy].\n    result : scipy.optimize.OptimizeResult\n        Optimization result object.\n\n    Notes\n    -----\n    The optimization minimizes:\n        E = E_data + \u03bb_smooth * E_smooth + \u03bb_biharm * E_biharm\n\n    where:\n    - E_data is the misfit between measured and predicted Stokes parameters\n    - E_smooth is the Laplacian penalty (\u2207\u00b2\u03c6)\u00b2\n    - E_biharm is the biharmonic penalty (\u2207\u2074\u03c6)\u00b2\n\n    Examples\n    --------\n    &gt;&gt;&gt; phi, stress, result = recover_stress_field_global(\n    ...     image_stack, wavelengths, C_values, nu=1.0, L=0.01,\n    ...     S_i_hat=np.array([1.0, 0.0, 0.0]), lambda_smooth=1e-5\n    ... )\n    \"\"\"\n    H, W, _, _ = image_stack.shape\n\n    if mask is None:\n        mask = np.ones((H, W), dtype=bool)\n\n    if verbose:\n        print(\"Setting up global optimization...\")\n        print(f\"Grid size: {H} x {W} = {H*W} points\")\n        print(f\"Regularization: \u03bb_smooth = {lambda_smooth:.2e}, \u03bb_biharm = {lambda_biharmonic:.2e}\")\n\n    # Build finite difference operators\n    D2x, D2y, Dxy, L_op = build_finite_difference_operators(W, H, dx, dy)\n\n    # Initialize Airy function\n    if initial_phi is None:\n        if verbose:\n            print(\"Computing initial guess from local solver...\")\n\n        # Use local solver for initialization\n        from photoelastimetry.local import recover_stress_map\n\n        stress_local = recover_stress_map(image_stack, wavelengths, C_values, nu, L, S_i_hat, n_jobs=1)\n\n        # Reconstruct Airy function from local stresses (approximate)\n        # This is an approximate inverse - we solve Poisson problems\n        sigma_xx_local = stress_local[:, :, 0].flatten()\n        sigma_yy_local = stress_local[:, :, 1].flatten()\n\n        # \u03c6_yy = \u03c3_xx and \u03c6_xx = \u03c3_yy\n        # Average these two constraints with regularization\n        A = D2x + D2y + lambda_smooth * L_op.T @ L_op\n        b = D2x @ sigma_yy_local + D2y @ sigma_xx_local\n\n        try:\n            phi_init = spsolve(A, b)\n        except:\n            # Fallback to zero initialization\n            if verbose:\n                print(\"Warning: Could not invert for initial Airy function, using zeros\")\n            phi_init = np.zeros(H * W)\n    else:\n        phi_init = initial_phi.flatten()\n\n    if verbose:\n        print(f\"Starting optimization with method '{method}'...\")\n\n    # Define callback for progress monitoring\n    iteration = [0]\n\n    def callback(xk):\n        iteration[0] += 1\n        if verbose and iteration[0] % 10 == 0:\n            residual = compute_global_residual(\n                xk,\n                image_stack,\n                wavelengths,\n                C_values,\n                nu,\n                L,\n                S_i_hat,\n                D2x,\n                D2y,\n                Dxy,\n                mask,\n                lambda_smooth,\n                lambda_biharmonic,\n            )\n            print(f\"Iteration {iteration[0]}: residual = {residual:.6e}\")\n\n    # Optimize\n    result = minimize(\n        compute_global_residual,\n        phi_init,\n        args=(\n            image_stack,\n            wavelengths,\n            C_values,\n            nu,\n            L,\n            S_i_hat,\n            D2x,\n            D2y,\n            Dxy,\n            mask,\n            lambda_smooth,\n            lambda_biharmonic,\n        ),\n        method=method,\n        options={\"maxiter\": maxiter, \"disp\": verbose},\n        callback=callback if verbose else None,\n    )\n\n    if verbose:\n        print(f\"\\nOptimization completed: {result.message}\")\n        print(f\"Final residual: {result.fun:.6e}\")\n        print(f\"Success: {result.success}\")\n\n    # Extract final solution\n    phi = result.x.reshape(H, W)\n\n    # Compute stress field\n    sigma_xx, sigma_yy, sigma_xy = airy_to_stress(result.x, D2x, D2y, Dxy)\n    stress_field = np.stack([sigma_xx.reshape(H, W), sigma_yy.reshape(H, W), sigma_xy.reshape(H, W)], axis=-1)\n\n    # Apply mask\n    stress_field[~mask] = np.nan\n\n    return phi, stress_field, result\n</code></pre>"},{"location":"reference/equilibrium_solver/#photoelastimetry.solver.equilibrium_solver.recover_stress_field_global_iterative","title":"<code>recover_stress_field_global_iterative(image_stack, wavelengths, C_values, nu, L, S_i_hat, mask=None, dx=1.0, dy=1.0, lambda_smooth=1e-06, n_iterations=5, local_init=True, verbose=True)</code>","text":"<p>Iterative global solver with alternating optimization strategy.</p> <p>This approach alternates between: 1. Fixing the stress field and optimizing Airy function (enforcing equilibrium) 2. Fixing Airy function and locally refining to fit data better</p> <p>This can be more robust than direct global optimization for difficult problems.</p> <p>Parameters:</p> Name Type Description Default <code>image_stack</code> <code>ndarray</code> <p>Image stack [H, W, 3, 4] with RGB channels and 4 polarization angles.</p> required <code>wavelengths</code> <code>array - like</code> <p>Wavelengths for RGB channels (m).</p> required <code>C_values</code> <code>array - like</code> <p>Stress-optic coefficients for RGB channels (1/Pa).</p> required <code>nu</code> <code>float or ndarray</code> <p>Solid fraction (use 1.0 for solid samples).</p> required <code>L</code> <code>float</code> <p>Sample thickness (m).</p> required <code>S_i_hat</code> <code>array - like</code> <p>Incoming normalized Stokes vector [S1_hat, S2_hat, S3_hat].</p> required <code>mask</code> <code>ndarray</code> <p>Boolean mask indicating valid pixels [H, W].</p> <code>None</code> <code>dx</code> <code>float</code> <p>Grid spacing (default: 1.0).</p> <code>1.0</code> <code>dy</code> <code>float</code> <p>Grid spacing (default: 1.0).</p> <code>1.0</code> <code>lambda_smooth</code> <code>float</code> <p>Regularization weight (default: 1e-6).</p> <code>1e-06</code> <code>n_iterations</code> <code>int</code> <p>Number of alternating iterations (default: 5).</p> <code>5</code> <code>local_init</code> <code>bool</code> <p>Initialize with local solver (default: True).</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>Print progress (default: True).</p> <code>True</code> <p>Returns:</p> Name Type Description <code>phi</code> <code>ndarray</code> <p>Airy stress function [H, W].</p> <code>stress_field</code> <code>ndarray</code> <p>Stress components [H, W, 3] = [\u03c3_xx, \u03c3_yy, \u03c3_xy].</p> <code>residuals</code> <code>list</code> <p>Residual at each iteration.</p> Source code in <code>photoelastimetry/solver/equilibrium_solver.py</code> <pre><code>def recover_stress_field_global_iterative(\n    image_stack,\n    wavelengths,\n    C_values,\n    nu,\n    L,\n    S_i_hat,\n    mask=None,\n    dx=1.0,\n    dy=1.0,\n    lambda_smooth=1e-6,\n    n_iterations=5,\n    local_init=True,\n    verbose=True,\n):\n    \"\"\"\n    Iterative global solver with alternating optimization strategy.\n\n    This approach alternates between:\n    1. Fixing the stress field and optimizing Airy function (enforcing equilibrium)\n    2. Fixing Airy function and locally refining to fit data better\n\n    This can be more robust than direct global optimization for difficult problems.\n\n    Parameters\n    ----------\n    image_stack : ndarray\n        Image stack [H, W, 3, 4] with RGB channels and 4 polarization angles.\n    wavelengths : array-like\n        Wavelengths for RGB channels (m).\n    C_values : array-like\n        Stress-optic coefficients for RGB channels (1/Pa).\n    nu : float or ndarray\n        Solid fraction (use 1.0 for solid samples).\n    L : float\n        Sample thickness (m).\n    S_i_hat : array-like\n        Incoming normalized Stokes vector [S1_hat, S2_hat, S3_hat].\n    mask : ndarray, optional\n        Boolean mask indicating valid pixels [H, W].\n    dx, dy : float, optional\n        Grid spacing (default: 1.0).\n    lambda_smooth : float, optional\n        Regularization weight (default: 1e-6).\n    n_iterations : int, optional\n        Number of alternating iterations (default: 5).\n    local_init : bool, optional\n        Initialize with local solver (default: True).\n    verbose : bool, optional\n        Print progress (default: True).\n\n    Returns\n    -------\n    phi : ndarray\n        Airy stress function [H, W].\n    stress_field : ndarray\n        Stress components [H, W, 3] = [\u03c3_xx, \u03c3_yy, \u03c3_xy].\n    residuals : list\n        Residual at each iteration.\n    \"\"\"\n    H, W, _, _ = image_stack.shape\n\n    if mask is None:\n        mask = np.ones((H, W), dtype=bool)\n\n    # Build operators\n    D2x, D2y, Dxy, L_op = build_finite_difference_operators(W, H, dx, dy)\n\n    # Initialize with local solver\n    if local_init:\n        if verbose:\n            print(\"Initializing with local solver...\")\n        from photoelastimetry.solver.stokes_solver import recover_stress_map\n\n        stress_field = recover_stress_map(image_stack, wavelengths, C_values, nu, L, S_i_hat, n_jobs=-1)\n    else:\n        stress_field = np.zeros((H, W, 3))\n\n    residuals = []\n\n    for iteration in range(n_iterations):\n        if verbose:\n            print(f\"\\n=== Iteration {iteration + 1}/{n_iterations} ===\")\n\n        # Step 1: Fit Airy function to current stress field\n        if verbose:\n            print(\"Fitting Airy function to stress field...\")\n\n        sigma_xx_flat = stress_field[:, :, 0].flatten()\n        sigma_yy_flat = stress_field[:, :, 1].flatten()\n        sigma_xy_flat = stress_field[:, :, 2].flatten()\n\n        # Set up least squares problem: minimize ||A \u03c6 - b||\u00b2 + \u03bb ||L \u03c6||\u00b2\n        # where A combines D2y (for \u03c3_xx), D2x (for \u03c3_yy), -Dxy (for \u03c3_xy)\n        from scipy.sparse import vstack\n\n        # Weight matrix for valid pixels\n        w = mask.flatten().astype(float)\n        W_diag = diags(w)\n\n        A = vstack(\n            [\n                W_diag @ D2y,  # \u03c3_xx = \u2202\u00b2\u03c6/\u2202y\u00b2\n                W_diag @ D2x,  # \u03c3_yy = \u2202\u00b2\u03c6/\u2202x\u00b2\n                -W_diag @ Dxy,  # \u03c3_xy = -\u2202\u00b2\u03c6/\u2202x\u2202y\n            ]\n        )\n\n        b = np.concatenate(\n            [\n                w * sigma_xx_flat,\n                w * sigma_yy_flat,\n                w * sigma_xy_flat,\n            ]\n        )\n\n        # Solve regularized least squares\n        AtA = A.T @ A + lambda_smooth * L_op.T @ L_op\n        Atb = A.T @ b\n\n        try:\n            phi_flat = spsolve(AtA, Atb)\n            phi = phi_flat.reshape(H, W)\n        except:\n            if verbose:\n                print(\"Warning: Sparse solve failed, using previous phi\")\n            phi = np.zeros((H, W))\n\n        # Step 2: Update stress field from Airy function\n        if verbose:\n            print(\"Computing stresses from Airy function...\")\n\n        sigma_xx, sigma_yy, sigma_xy = airy_to_stress(phi_flat, D2x, D2y, Dxy)\n        stress_field = np.stack(\n            [sigma_xx.reshape(H, W), sigma_yy.reshape(H, W), sigma_xy.reshape(H, W)], axis=-1\n        )\n\n        # Step 3: Refine with local optimization where needed\n        if iteration &lt; n_iterations - 1:  # Skip on last iteration\n            if verbose:\n                print(\"Refining with local optimization...\")\n\n            # Only refine pixels with high residuals\n            n_refined = 0\n            for i in tqdm(range(H), desc=\"Local refinement\", disable=not verbose):\n                for j in range(W):\n                    if not mask[i, j]:\n                        continue\n\n                    # Get measured Stokes\n                    S_m_hat = np.zeros((3, 2))\n                    valid = True\n                    for c in range(3):\n                        I = image_stack[i, j, c, :]\n                        if np.isnan(I).any():\n                            valid = False\n                            break\n                        S0, S1, S2 = stokes_solver.compute_stokes_components(I[0], I[1], I[2], I[3])\n                        S1_hat, S2_hat = stokes_solver.compute_normalized_stokes(S0, S1, S2)\n                        S_m_hat[c, 0] = S1_hat\n                        S_m_hat[c, 1] = S2_hat\n\n                    if not valid:\n                        continue\n\n                    # Local refinement with current stress as initial guess\n                    nu_pixel = nu if np.isscalar(nu) else nu[i, j]\n                    initial_guess = stress_field[i, j, :]\n\n                    stress_refined, success = stokes_solver.recover_stress_tensor(\n                        S_m_hat, wavelengths, C_values, nu_pixel, L, S_i_hat, initial_guess=initial_guess\n                    )\n\n                    if success:\n                        stress_field[i, j, :] = stress_refined\n                        n_refined += 1\n\n            if verbose:\n                print(f\"Refined {n_refined} pixels\")\n\n        # Compute residual\n        residual = compute_global_residual(\n            phi_flat,\n            image_stack,\n            wavelengths,\n            C_values,\n            nu,\n            L,\n            S_i_hat,\n            D2x,\n            D2y,\n            Dxy,\n            mask,\n            lambda_smooth,\n            0.0,\n        )\n        residuals.append(residual)\n\n        if verbose:\n            print(f\"Residual: {residual:.6e}\")\n\n    # Apply mask\n    stress_field[~mask] = np.nan\n\n    return phi, stress_field, residuals\n</code></pre>"},{"location":"reference/equilibrium_solver/#photoelastimetry.solver.equilibrium_solver.compare_local_vs_global","title":"<code>compare_local_vs_global(image_stack, wavelengths, C_values, nu, L, S_i_hat, mask=None, lambda_smooth=1e-06, true_stress=None)</code>","text":"<p>Compare local and global inversion methods.</p> <p>This utility function runs both methods and provides comparison metrics. Useful for validation and parameter tuning.</p> <p>Parameters:</p> Name Type Description Default <code>image_stack</code> <code>ndarray</code> <p>Image stack [H, W, 3, 4].</p> required <code>wavelengths</code> <code>array - like</code> <p>Wavelengths for RGB channels (m).</p> required <code>C_values</code> <code>array - like</code> <p>Stress-optic coefficients (1/Pa).</p> required <code>nu</code> <code>float or ndarray</code> <p>Solid fraction.</p> required <code>L</code> <code>float</code> <p>Sample thickness (m).</p> required <code>S_i_hat</code> <code>array - like</code> <p>Incoming Stokes vector.</p> required <code>mask</code> <code>ndarray</code> <p>Valid pixel mask.</p> <code>None</code> <code>lambda_smooth</code> <code>float</code> <p>Regularization for global method.</p> <code>1e-06</code> <code>true_stress</code> <code>ndarray</code> <p>Ground truth stress field [H, W, 3] for validation.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>results</code> <code>dict</code> <p>Dictionary containing: - 'local_stress': Local solver result - 'global_stress': Global solver result - 'global_phi': Airy function - 'local_residual': Data misfit for local - 'global_residual': Data misfit for global - 'local_smoothness': Smoothness metric for local - 'global_smoothness': Smoothness metric for global - 'local_error': Error vs truth (if provided) - 'global_error': Error vs truth (if provided)</p> Source code in <code>photoelastimetry/solver/equilibrium_solver.py</code> <pre><code>def compare_local_vs_global(\n    image_stack,\n    wavelengths,\n    C_values,\n    nu,\n    L,\n    S_i_hat,\n    mask=None,\n    lambda_smooth=1e-6,\n    true_stress=None,\n):\n    \"\"\"\n    Compare local and global inversion methods.\n\n    This utility function runs both methods and provides comparison metrics.\n    Useful for validation and parameter tuning.\n\n    Parameters\n    ----------\n    image_stack : ndarray\n        Image stack [H, W, 3, 4].\n    wavelengths : array-like\n        Wavelengths for RGB channels (m).\n    C_values : array-like\n        Stress-optic coefficients (1/Pa).\n    nu : float or ndarray\n        Solid fraction.\n    L : float\n        Sample thickness (m).\n    S_i_hat : array-like\n        Incoming Stokes vector.\n    mask : ndarray, optional\n        Valid pixel mask.\n    lambda_smooth : float, optional\n        Regularization for global method.\n    true_stress : ndarray, optional\n        Ground truth stress field [H, W, 3] for validation.\n\n    Returns\n    -------\n    results : dict\n        Dictionary containing:\n        - 'local_stress': Local solver result\n        - 'global_stress': Global solver result\n        - 'global_phi': Airy function\n        - 'local_residual': Data misfit for local\n        - 'global_residual': Data misfit for global\n        - 'local_smoothness': Smoothness metric for local\n        - 'global_smoothness': Smoothness metric for global\n        - 'local_error': Error vs truth (if provided)\n        - 'global_error': Error vs truth (if provided)\n    \"\"\"\n    from photoelastimetry.local import recover_stress_map\n\n    print(\"=== Running Local Solver ===\")\n    stress_local = recover_stress_map(image_stack, wavelengths, C_values, nu, L, S_i_hat, n_jobs=-1)\n\n    print(\"\\n=== Running Global Solver ===\")\n    phi, stress_global, result = recover_stress_field_global(\n        image_stack,\n        wavelengths,\n        C_values,\n        nu,\n        L,\n        S_i_hat,\n        mask=mask,\n        lambda_smooth=lambda_smooth,\n        initial_phi=None,\n        maxiter=500,\n        verbose=True,\n    )\n\n    # Compute metrics\n    H, W = image_stack.shape[:2]\n    D2x, D2y, Dxy, L_op = build_finite_difference_operators(W, H)\n\n    if mask is None:\n        mask = np.ones((H, W), dtype=bool)\n\n    # Data residuals\n    local_residual = compute_global_residual(\n        stress_local.flatten(),\n        image_stack,\n        wavelengths,\n        C_values,\n        nu,\n        L,\n        S_i_hat,\n        D2x,\n        D2y,\n        Dxy,\n        mask,\n        0.0,\n        0.0,\n    )\n\n    global_residual = result.fun\n\n    # Smoothness (total variation)\n    def compute_smoothness(stress):\n        grad_x = np.gradient(stress, axis=1)\n        grad_y = np.gradient(stress, axis=0)\n        return np.nanmean(grad_x**2 + grad_y**2)\n\n    local_smoothness = sum(compute_smoothness(stress_local[:, :, i]) for i in range(3))\n    global_smoothness = sum(compute_smoothness(stress_global[:, :, i]) for i in range(3))\n\n    results = {\n        \"local_stress\": stress_local,\n        \"global_stress\": stress_global,\n        \"global_phi\": phi,\n        \"local_residual\": local_residual,\n        \"global_residual\": global_residual,\n        \"local_smoothness\": local_smoothness,\n        \"global_smoothness\": global_smoothness,\n    }\n\n    # Error vs ground truth\n    if true_stress is not None:\n        local_error = np.nanmean((stress_local - true_stress) ** 2)\n        global_error = np.nanmean((stress_global - true_stress) ** 2)\n        results[\"local_error\"] = local_error\n        results[\"global_error\"] = global_error\n\n        print(f\"\\n=== Comparison Results ===\")\n        print(f\"Local RMSE vs truth: {np.sqrt(local_error):.6e}\")\n        print(f\"Global RMSE vs truth: {np.sqrt(global_error):.6e}\")\n\n    print(f\"\\nLocal data residual: {local_residual:.6e}\")\n    print(f\"Global data residual: {global_residual:.6e}\")\n    print(f\"Local smoothness: {local_smoothness:.6e}\")\n    print(f\"Global smoothness: {global_smoothness:.6e}\")\n\n    return results\n</code></pre>"},{"location":"reference/image/","title":"image","text":"<p>Image processing and Mueller matrix operations.</p> <p>This module provides core image processing functions including Mueller matrix calculations, retardance computation, and principal angle extraction for photoelastic analysis.</p>"},{"location":"reference/image/#photoelastimetry.image","title":"<code>image</code>","text":"<p>Image processing and photoelastic forward model functions.</p> <p>This module contains helper functions for polarimetric image analysis and photoelastic forward modeling, including stress-to-optical transformations.</p>"},{"location":"reference/image/#photoelastimetry.image-functions","title":"Functions","text":""},{"location":"reference/image/#photoelastimetry.image.DoLP","title":"<code>DoLP(image)</code>","text":"<p>Calculate the Degree of Linear Polarisation (DoLP).</p> Source code in <code>photoelastimetry/image.py</code> <pre><code>def DoLP(image):\n    \"\"\"\n    Calculate the Degree of Linear Polarisation (DoLP).\n    \"\"\"\n    I = np.sum(image, axis=3)  # total intensity ovr all polarisation states\n\n    Q = image[:, :, :, 0] - image[:, :, :, 1]  # 0/90 difference\n    U = image[:, :, :, 2] - image[:, :, :, 3]  # 45/135 difference\n\n    return np.sqrt(Q**2 + U**2) / I\n</code></pre>"},{"location":"reference/image/#photoelastimetry.image.AoLP","title":"<code>AoLP(image)</code>","text":"<p>Calculate the Angle of Linear Polarisation (AoLP).</p> Source code in <code>photoelastimetry/image.py</code> <pre><code>def AoLP(image):\n    \"\"\"\n    Calculate the Angle of Linear Polarisation (AoLP).\n    \"\"\"\n\n    Q = image[:, :, :, 0] - image[:, :, :, 1]  # 0/90 difference\n    U = image[:, :, :, 2] - image[:, :, :, 3]  # 45/135 difference\n\n    return 0.5 * np.arctan2(U, Q)\n</code></pre>"},{"location":"reference/image/#photoelastimetry.image.compute_retardance","title":"<code>compute_retardance(sigma_xx, sigma_yy, sigma_xy, C, nu, L, wavelength)</code>","text":"<p>Compute retardance for a given stress tensor and material properties.</p> <p>Parameters:</p> Name Type Description Default <code>sigma_xx</code> <code>float or array - like</code> <p>Normal stress component in x direction (Pa).</p> required <code>sigma_yy</code> <code>float or array - like</code> <p>Normal stress component in y direction (Pa).</p> required <code>sigma_xy</code> <code>float or array - like</code> <p>Shear stress component (Pa).</p> required <code>C</code> <code>float</code> <p>Stress-optic coefficient for the colour channel (1/Pa).</p> required <code>nu</code> <code>float</code> <p>Solid fraction (dimensionless). For solid samples, use nu=1.0. For porous samples, this represents the effective optical path length factor relative to sample thickness.</p> required <code>L</code> <code>float</code> <p>Sample thickness (m).</p> required <code>wavelength</code> <code>float</code> <p>Wavelength of light (m).</p> required <p>Returns:</p> Name Type Description <code>delta</code> <code>float or array - like</code> <p>Retardance (radians).</p> Notes <p>The retardance formula is: \u03b4 = (2\u03c0CnL/\u03bb) * \u221a[(\u03c3_xx - \u03c3_yy)\u00b2 + 4\u03c3_xy\u00b2] where the principal stress difference determines the birefringence magnitude.</p> Source code in <code>photoelastimetry/image.py</code> <pre><code>def compute_retardance(sigma_xx, sigma_yy, sigma_xy, C, nu, L, wavelength):\n    \"\"\"\n    Compute retardance for a given stress tensor and material properties.\n\n    Parameters\n    ----------\n    sigma_xx : float or array-like\n        Normal stress component in x direction (Pa).\n    sigma_yy : float or array-like\n        Normal stress component in y direction (Pa).\n    sigma_xy : float or array-like\n        Shear stress component (Pa).\n    C : float\n        Stress-optic coefficient for the colour channel (1/Pa).\n    nu : float\n        Solid fraction (dimensionless).\n        For solid samples, use nu=1.0. For porous samples, this represents\n        the effective optical path length factor relative to sample thickness.\n    L : float\n        Sample thickness (m).\n    wavelength : float\n        Wavelength of light (m).\n\n    Returns\n    -------\n    delta : float or array-like\n        Retardance (radians).\n\n    Notes\n    -----\n    The retardance formula is: \u03b4 = (2\u03c0CnL/\u03bb) * \u221a[(\u03c3_xx - \u03c3_yy)\u00b2 + 4\u03c3_xy\u00b2]\n    where the principal stress difference determines the birefringence magnitude.\n    \"\"\"\n    principal_stress_diff = np.sqrt((sigma_xx - sigma_yy) ** 2 + 4 * sigma_xy**2)\n    delta = (2 * np.pi * C * nu * L / wavelength) * principal_stress_diff\n    return delta\n</code></pre>"},{"location":"reference/image/#photoelastimetry.image.compute_principal_angle","title":"<code>compute_principal_angle(sigma_xx, sigma_yy, sigma_xy)</code>","text":"<p>Compute the orientation angle of the principal stress direction.</p> <p>Parameters:</p> Name Type Description Default <code>sigma_xx</code> <code>float or array - like</code> <p>Normal stress component in x direction (Pa).</p> required <code>sigma_yy</code> <code>float or array - like</code> <p>Normal stress component in y direction (Pa).</p> required <code>sigma_xy</code> <code>float or array - like</code> <p>Shear stress component (Pa).</p> required <p>Returns:</p> Name Type Description <code>theta</code> <code>float or array - like</code> <p>Principal stress orientation angle (radians).</p> Notes <p>In photoelasticity, the fast axis aligns with the maximum compressive stress direction. This formula gives the angle to the maximum tensile stress (\u03c3_max).</p> Source code in <code>photoelastimetry/image.py</code> <pre><code>def compute_principal_angle(sigma_xx, sigma_yy, sigma_xy):\n    \"\"\"\n    Compute the orientation angle of the principal stress direction.\n\n    Parameters\n    ----------\n    sigma_xx : float or array-like\n        Normal stress component in x direction (Pa).\n    sigma_yy : float or array-like\n        Normal stress component in y direction (Pa).\n    sigma_xy : float or array-like\n        Shear stress component (Pa).\n\n    Returns\n    -------\n    theta : float or array-like\n        Principal stress orientation angle (radians).\n\n    Notes\n    -----\n    In photoelasticity, the fast axis aligns with the maximum compressive\n    stress direction. This formula gives the angle to the maximum tensile\n    stress (\u03c3_max).\n    \"\"\"\n    theta = 0.5 * np.arctan2(2 * sigma_xy, sigma_xx - sigma_yy)\n    return theta\n</code></pre>"},{"location":"reference/image/#photoelastimetry.image.mueller_matrix","title":"<code>mueller_matrix(theta, delta)</code>","text":"<p>Compute the Mueller matrix for a birefringent material.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>float or array - like</code> <p>Orientation angle of principal stress direction (radians).</p> required <code>delta</code> <code>float or array - like</code> <p>Retardance (radians).</p> required <p>Returns:</p> Name Type Description <code>M</code> <code>ndarray</code> <p>Mueller matrix (4x4) for scalar inputs, or (..., 4, 4) for array inputs.</p> Source code in <code>photoelastimetry/image.py</code> <pre><code>def mueller_matrix(theta, delta):\n    \"\"\"\n    Compute the Mueller matrix for a birefringent material.\n\n    Parameters\n    ----------\n    theta : float or array-like\n        Orientation angle of principal stress direction (radians).\n    delta : float or array-like\n        Retardance (radians).\n\n    Returns\n    -------\n    M : ndarray\n        Mueller matrix (4x4) for scalar inputs, or (..., 4, 4) for array inputs.\n    \"\"\"\n    cos_2theta = np.cos(2 * theta)\n    sin_2theta = np.sin(2 * theta)\n    cos_delta = np.cos(delta)\n    sin_delta = np.sin(delta)\n\n    # Handle scalar vs array inputs\n    if np.isscalar(theta) and np.isscalar(delta):\n        M = np.array(\n            [\n                [1, 0, 0, 0],\n                [\n                    0,\n                    cos_2theta**2 + sin_2theta**2 * cos_delta,\n                    cos_2theta * sin_2theta * (1 - cos_delta),\n                    sin_2theta * sin_delta,\n                ],\n                [\n                    0,\n                    cos_2theta * sin_2theta * (1 - cos_delta),\n                    cos_2theta**2 * cos_delta + sin_2theta**2,\n                    -cos_2theta * sin_delta,\n                ],\n                [0, -sin_2theta * sin_delta, cos_2theta * sin_delta, cos_delta],\n            ]\n        )\n    else:\n        # Array case - build matrix with proper shape (..., 4, 4)\n        shape = np.broadcast(theta, delta).shape\n        M = np.zeros(shape + (4, 4))\n\n        M[..., 0, 0] = 1\n        M[..., 1, 1] = cos_2theta**2 + sin_2theta**2 * cos_delta\n        M[..., 1, 2] = cos_2theta * sin_2theta * (1 - cos_delta)\n        M[..., 1, 3] = sin_2theta * sin_delta\n        M[..., 2, 1] = cos_2theta * sin_2theta * (1 - cos_delta)\n        M[..., 2, 2] = cos_2theta**2 * cos_delta + sin_2theta**2\n        M[..., 2, 3] = -cos_2theta * sin_delta\n        M[..., 3, 1] = -sin_2theta * sin_delta\n        M[..., 3, 2] = cos_2theta * sin_delta\n        M[..., 3, 3] = cos_delta\n\n    return M\n</code></pre>"},{"location":"reference/intensity_solver/","title":"solver.intensity_solver","text":"<p>Intensity-based pixel-wise stress inversion.</p> <p>This module provides an alternative approach that works directly with raw polarization intensities rather than Stokes components. This can be beneficial when raw intensities provide more reliable measurements.</p>"},{"location":"reference/intensity_solver/#key-functions","title":"Key Functions","text":"<ul> <li><code>predict_intensity()</code> - Forward model for intensity prediction</li> <li><code>recover_stress_map_intensity()</code> - Main function for intensity-based stress recovery</li> <li><code>compare_stokes_vs_intensity()</code> - Compare Stokes and intensity-based methods</li> </ul>"},{"location":"reference/intensity_solver/#photoelastimetry.solver.intensity_solver","title":"<code>intensity_solver</code>","text":"<p>Intensity-based stress measurement using raw polarimetric intensities.</p> <p>This module implements stress tensor recovery by optimizing directly on raw polarization intensity measurements rather than normalized Stokes components. This approach:</p> <ol> <li>Avoids information loss from normalization</li> <li>Eliminates angle-wrapping ambiguities from Stokes \u2192 angle conversion</li> <li>Allows proper statistical modeling of detector noise (Poisson + Gaussian)</li> <li>Enables joint calibration of instrument parameters</li> <li>Provides more robust inversion near degenerate points (low retardance)</li> </ol> <p>The forward model predicts intensity for each analyzer angle and wavelength from the stress tensor via Mueller/Jones calculus.</p>"},{"location":"reference/intensity_solver/#photoelastimetry.solver.intensity_solver-functions","title":"Functions","text":""},{"location":"reference/intensity_solver/#photoelastimetry.solver.intensity_solver.predict_intensity","title":"<code>predict_intensity(sigma_xx, sigma_yy, sigma_xy, C, nu, L, wavelength, analyzer_angles, S_i_hat, I0=1.0)</code>","text":"<p>Predict intensity measurements for different analyzer angles.</p> <p>Parameters:</p> Name Type Description Default <code>sigma_xx</code> <code>float</code> <p>Normal stress component in x direction (Pa).</p> required <code>sigma_yy</code> <code>float</code> <p>Normal stress component in y direction (Pa).</p> required <code>sigma_xy</code> <code>float</code> <p>Shear stress component (Pa).</p> required <code>C</code> <code>float</code> <p>Stress-optic coefficient (1/Pa).</p> required <code>nu</code> <code>float</code> <p>Solid fraction (use 1.0 for solid samples).</p> required <code>L</code> <code>float</code> <p>Sample thickness (m).</p> required <code>wavelength</code> <code>float</code> <p>Wavelength of light (m).</p> required <code>analyzer_angles</code> <code>array - like</code> <p>Analyzer angles in radians [0, \u03c0/4, \u03c0/2, 3\u03c0/4].</p> required <code>S_i_hat</code> <code>array - like</code> <p>Incoming normalized Stokes vector [S1_hat, S2_hat, S3_hat].</p> required <code>I0</code> <code>float</code> <p>Incident intensity (default: 1.0).</p> <code>1.0</code> <p>Returns:</p> Name Type Description <code>intensities</code> <code>ndarray</code> <p>Predicted intensities for each analyzer angle.</p> Notes <p>The intensity at analyzer angle \u03b1 is computed using Mueller calculus:     I(\u03b1) = [1, cos(2\u03b1), sin(2\u03b1), 0] @ M_sample @ S_in</p> <p>where M_sample is the Mueller matrix of the birefringent sample.</p> Source code in <code>photoelastimetry/solver/intensity_solver.py</code> <pre><code>def predict_intensity(\n    sigma_xx,\n    sigma_yy,\n    sigma_xy,\n    C,\n    nu,\n    L,\n    wavelength,\n    analyzer_angles,\n    S_i_hat,\n    I0=1.0,\n):\n    \"\"\"\n    Predict intensity measurements for different analyzer angles.\n\n    Parameters\n    ----------\n    sigma_xx : float\n        Normal stress component in x direction (Pa).\n    sigma_yy : float\n        Normal stress component in y direction (Pa).\n    sigma_xy : float\n        Shear stress component (Pa).\n    C : float\n        Stress-optic coefficient (1/Pa).\n    nu : float\n        Solid fraction (use 1.0 for solid samples).\n    L : float\n        Sample thickness (m).\n    wavelength : float\n        Wavelength of light (m).\n    analyzer_angles : array-like\n        Analyzer angles in radians [0, \u03c0/4, \u03c0/2, 3\u03c0/4].\n    S_i_hat : array-like\n        Incoming normalized Stokes vector [S1_hat, S2_hat, S3_hat].\n    I0 : float, optional\n        Incident intensity (default: 1.0).\n\n    Returns\n    -------\n    intensities : ndarray\n        Predicted intensities for each analyzer angle.\n\n    Notes\n    -----\n    The intensity at analyzer angle \u03b1 is computed using Mueller calculus:\n        I(\u03b1) = [1, cos(2\u03b1), sin(2\u03b1), 0] @ M_sample @ S_in\n\n    where M_sample is the Mueller matrix of the birefringent sample.\n    \"\"\"\n    # Compute retardance and fast axis orientation from stress\n    theta = compute_principal_angle(sigma_xx, sigma_yy, sigma_xy)\n    delta = compute_retardance(sigma_xx, sigma_yy, sigma_xy, C, nu, L, wavelength)\n\n    # Get sample Mueller matrix\n    M = mueller_matrix(theta, delta)\n\n    # Incident Stokes vector from S_i_hat\n    # S_in = I0 * [1, cos(2*pol_angle), sin(2*pol_angle), 0]\n    S_i_hat = np.asarray(S_i_hat)\n    S_in = I0 * np.array([1.0, S_i_hat[0], S_i_hat[1], S_i_hat[2]])\n\n    # Transmitted Stokes vector\n    S_out = M @ S_in\n\n    # Measure intensity through analyzer at each angle\n    # Analyzer at angle \u03b1 transmits: I = (S0 + S1*cos(2\u03b1) + S2*sin(2\u03b1)) / 2\n    intensities = np.zeros(len(analyzer_angles))\n    for i, alpha in enumerate(analyzer_angles):\n        cos_2a = np.cos(2 * alpha)\n        sin_2a = np.sin(2 * alpha)\n        # Intensity = (S0 + S1*cos(2\u03b1) + S2*sin(2\u03b1)) / 2\n        intensities[i] = 0.5 * (S_out[0] + S_out[1] * cos_2a + S_out[2] * sin_2a)\n\n    return intensities\n</code></pre>"},{"location":"reference/intensity_solver/#photoelastimetry.solver.intensity_solver.compute_intensity_residual","title":"<code>compute_intensity_residual(stress_params, I_measured, wavelengths, C_values, nu, L, analyzer_angles, S_i_hat, I0=1.0, weights=None)</code>","text":"<p>Compute residual between measured and predicted intensities.</p> <p>Parameters:</p> Name Type Description Default <code>stress_params</code> <code>array - like</code> <p>Stress tensor components [sigma_xx, sigma_yy, sigma_xy].</p> required <code>I_measured</code> <code>ndarray</code> <p>Measured intensities, shape (n_wavelengths, n_angles). Typically (3, 4) for RGB \u00d7 4 analyzer angles.</p> required <code>wavelengths</code> <code>array - like</code> <p>Wavelengths for each channel (m).</p> required <code>C_values</code> <code>array - like</code> <p>Stress-optic coefficients for each channel (1/Pa).</p> required <code>nu</code> <code>float</code> <p>Solid fraction (use 1.0 for solid samples).</p> required <code>L</code> <code>float</code> <p>Sample thickness (m).</p> required <code>analyzer_angles</code> <code>array - like</code> <p>Analyzer angles in radians [0, \u03c0/4, \u03c0/2, 3\u03c0/4].</p> required <code>S_i_hat</code> <code>array - like</code> <p>Incoming normalized Stokes vector [S1_hat, S2_hat, S3_hat].</p> required <code>I0</code> <code>float</code> <p>Incident intensity (default: 1.0).</p> <code>1.0</code> <code>weights</code> <code>ndarray</code> <p>Weights for residuals, shape matching I_measured. If None, uniform weighting is used.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>residual</code> <code>ndarray</code> <p>Flattened array of weighted residuals.</p> Source code in <code>photoelastimetry/solver/intensity_solver.py</code> <pre><code>def compute_intensity_residual(\n    stress_params,\n    I_measured,\n    wavelengths,\n    C_values,\n    nu,\n    L,\n    analyzer_angles,\n    S_i_hat,\n    I0=1.0,\n    weights=None,\n):\n    \"\"\"\n    Compute residual between measured and predicted intensities.\n\n    Parameters\n    ----------\n    stress_params : array-like\n        Stress tensor components [sigma_xx, sigma_yy, sigma_xy].\n    I_measured : ndarray\n        Measured intensities, shape (n_wavelengths, n_angles).\n        Typically (3, 4) for RGB \u00d7 4 analyzer angles.\n    wavelengths : array-like\n        Wavelengths for each channel (m).\n    C_values : array-like\n        Stress-optic coefficients for each channel (1/Pa).\n    nu : float\n        Solid fraction (use 1.0 for solid samples).\n    L : float\n        Sample thickness (m).\n    analyzer_angles : array-like\n        Analyzer angles in radians [0, \u03c0/4, \u03c0/2, 3\u03c0/4].\n    S_i_hat : array-like\n        Incoming normalized Stokes vector [S1_hat, S2_hat, S3_hat].\n    I0 : float, optional\n        Incident intensity (default: 1.0).\n    weights : ndarray, optional\n        Weights for residuals, shape matching I_measured.\n        If None, uniform weighting is used.\n\n    Returns\n    -------\n    residual : ndarray\n        Flattened array of weighted residuals.\n    \"\"\"\n    sigma_xx, sigma_yy, sigma_xy = stress_params\n\n    residuals = []\n\n    for c, (wavelength, C) in enumerate(zip(wavelengths, C_values)):\n        I_pred = predict_intensity(\n            sigma_xx,\n            sigma_yy,\n            sigma_xy,\n            C,\n            nu,\n            L,\n            wavelength,\n            analyzer_angles,\n            S_i_hat,\n            I0,\n        )\n\n        diff = I_measured[c] - I_pred\n\n        # Apply weights if provided (for Poisson noise: weight ~ 1/sqrt(I))\n        if weights is not None:\n            diff *= weights[c]\n\n        residuals.append(diff)\n\n    return np.concatenate(residuals)\n</code></pre>"},{"location":"reference/intensity_solver/#photoelastimetry.solver.intensity_solver.recover_stress_tensor_intensity","title":"<code>recover_stress_tensor_intensity(I_measured, wavelengths, C_values, nu, L, S_i_hat, analyzer_angles=None, I0=1.0, weights=None, initial_guess=None, method='lm', bounds=None)</code>","text":"<p>Recover stress tensor from raw intensity measurements.</p> <p>This function inverts the forward model to find the stress tensor that best explains the measured intensities across all wavelengths and analyzer angles.</p> <p>Parameters:</p> Name Type Description Default <code>I_measured</code> <code>ndarray</code> <p>Measured intensities, shape (n_wavelengths, n_angles). Typically (3, 4) for RGB \u00d7 4 analyzer angles [0\u00b0, 45\u00b0, 90\u00b0, 135\u00b0].</p> required <code>wavelengths</code> <code>array - like</code> <p>Wavelengths for R, G, B channels (m).</p> required <code>C_values</code> <code>array - like</code> <p>Stress-optic coefficients for R, G, B channels (1/Pa).</p> required <code>nu</code> <code>float</code> <p>Solid fraction (use 1.0 for solid samples).</p> required <code>L</code> <code>float</code> <p>Sample thickness (m).</p> required <code>analyzer_angles</code> <code>array - like</code> <p>Analyzer angles in radians. Default: [0, \u03c0/4, \u03c0/2, 3\u03c0/4].</p> <code>None</code> <code>S_i_hat</code> <code>array - like</code> <p>Incoming normalized Stokes vector [S1_hat, S2_hat, S3_hat].</p> required <code>I0</code> <code>float</code> <p>Incident intensity for normalization (default: 1.0).</p> <code>1.0</code> <code>weights</code> <code>ndarray</code> <p>Weights for residuals, shape matching I_measured. For Poisson noise, use weights[c, i] = 1/sqrt(I_measured[c, i]). If None, uniform weighting is used.</p> <code>None</code> <code>initial_guess</code> <code>array - like</code> <p>Initial guess for stress tensor [sigma_xx, sigma_yy, sigma_xy]. If None, computed from Stokes-based quick estimate.</p> <code>None</code> <code>method</code> <code>str</code> <p>Optimization method: 'lm' (Levenberg-Marquardt, default), 'trf', 'dogbox', or 'nelder-mead'.</p> <code>'lm'</code> <code>bounds</code> <code>tuple of array-like</code> <p>Lower and upper bounds for parameters (lower, upper). Each should be array of length 3 for [sigma_xx, sigma_yy, sigma_xy]. Default: (-1e9, 1e9) Pa for all components.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>stress_tensor</code> <code>ndarray</code> <p>Recovered stress tensor components [sigma_xx, sigma_yy, sigma_xy].</p> <code>success</code> <code>bool</code> <p>Whether optimization was successful.</p> <code>result</code> <code>OptimizeResult</code> <p>Full optimization result object.</p> Notes <p>This method is generally more accurate than Stokes-based inversion when: - High precision is required - Working near zero retardance (degenerate cases) - Principal stress axes aligned with incident polarization - Want to model detector noise properly (Poisson statistics)</p> <p>For typical usage, the Stokes-based method is faster and often sufficient.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Typical usage with 3 wavelengths, 4 analyzer angles\n&gt;&gt;&gt; I_measured = np.array([[I0_R, I45_R, I90_R, I135_R],\n...                        [I0_G, I45_G, I90_G, I135_G],\n...                        [I0_B, I45_B, I90_B, I135_B]])\n&gt;&gt;&gt; wavelengths = np.array([650e-9, 550e-9, 450e-9])\n&gt;&gt;&gt; C_values = np.array([2e-12, 2e-12, 2e-12])\n&gt;&gt;&gt; stress, success, result = recover_stress_tensor_intensity(\n...     I_measured, wavelengths, C_values, nu=1.0, L=0.01\n... )\n</code></pre> Source code in <code>photoelastimetry/solver/intensity_solver.py</code> <pre><code>def recover_stress_tensor_intensity(\n    I_measured,\n    wavelengths,\n    C_values,\n    nu,\n    L,\n    S_i_hat,\n    analyzer_angles=None,\n    I0=1.0,\n    weights=None,\n    initial_guess=None,\n    method=\"lm\",\n    bounds=None,\n):\n    \"\"\"\n    Recover stress tensor from raw intensity measurements.\n\n    This function inverts the forward model to find the stress tensor that\n    best explains the measured intensities across all wavelengths and analyzer\n    angles.\n\n    Parameters\n    ----------\n    I_measured : ndarray\n        Measured intensities, shape (n_wavelengths, n_angles).\n        Typically (3, 4) for RGB \u00d7 4 analyzer angles [0\u00b0, 45\u00b0, 90\u00b0, 135\u00b0].\n    wavelengths : array-like\n        Wavelengths for R, G, B channels (m).\n    C_values : array-like\n        Stress-optic coefficients for R, G, B channels (1/Pa).\n    nu : float\n        Solid fraction (use 1.0 for solid samples).\n    L : float\n        Sample thickness (m).\n    analyzer_angles : array-like, optional\n        Analyzer angles in radians. Default: [0, \u03c0/4, \u03c0/2, 3\u03c0/4].\n    S_i_hat : array-like\n        Incoming normalized Stokes vector [S1_hat, S2_hat, S3_hat].\n    I0 : float, optional\n        Incident intensity for normalization (default: 1.0).\n    weights : ndarray, optional\n        Weights for residuals, shape matching I_measured.\n        For Poisson noise, use weights[c, i] = 1/sqrt(I_measured[c, i]).\n        If None, uniform weighting is used.\n    initial_guess : array-like, optional\n        Initial guess for stress tensor [sigma_xx, sigma_yy, sigma_xy].\n        If None, computed from Stokes-based quick estimate.\n    method : str, optional\n        Optimization method: 'lm' (Levenberg-Marquardt, default),\n        'trf', 'dogbox', or 'nelder-mead'.\n    bounds : tuple of array-like, optional\n        Lower and upper bounds for parameters (lower, upper).\n        Each should be array of length 3 for [sigma_xx, sigma_yy, sigma_xy].\n        Default: (-1e9, 1e9) Pa for all components.\n\n    Returns\n    -------\n    stress_tensor : ndarray\n        Recovered stress tensor components [sigma_xx, sigma_yy, sigma_xy].\n    success : bool\n        Whether optimization was successful.\n    result : OptimizeResult\n        Full optimization result object.\n\n    Notes\n    -----\n    This method is generally more accurate than Stokes-based inversion when:\n    - High precision is required\n    - Working near zero retardance (degenerate cases)\n    - Principal stress axes aligned with incident polarization\n    - Want to model detector noise properly (Poisson statistics)\n\n    For typical usage, the Stokes-based method is faster and often sufficient.\n\n    Examples\n    --------\n    &gt;&gt;&gt; # Typical usage with 3 wavelengths, 4 analyzer angles\n    &gt;&gt;&gt; I_measured = np.array([[I0_R, I45_R, I90_R, I135_R],\n    ...                        [I0_G, I45_G, I90_G, I135_G],\n    ...                        [I0_B, I45_B, I90_B, I135_B]])\n    &gt;&gt;&gt; wavelengths = np.array([650e-9, 550e-9, 450e-9])\n    &gt;&gt;&gt; C_values = np.array([2e-12, 2e-12, 2e-12])\n    &gt;&gt;&gt; stress, success, result = recover_stress_tensor_intensity(\n    ...     I_measured, wavelengths, C_values, nu=1.0, L=0.01\n    ... )\n    \"\"\"\n    if analyzer_angles is None:\n        analyzer_angles = np.array([0, np.pi / 4, np.pi / 2, 3 * np.pi / 4])\n\n    # Compute initial guess from Stokes-based method if not provided\n    if initial_guess is None:\n        # Quick estimate: compute Stokes and use closed-form estimate\n        from photoelastimetry.solver.stokes_solver import (\n            compute_normalized_stokes,\n            compute_stokes_components,\n            recover_stress_tensor,\n        )\n\n        S_m_hat = np.zeros((len(wavelengths), 2))\n\n        for c in range(len(wavelengths)):\n            I_data = I_measured[c]\n            # compute_stokes_components expects: I_0, I_45, I_90, I_135\n            # Our analyzer_angles are [0, \u03c0/4, \u03c0/2, 3\u03c0/4] so ordering matches\n            if len(I_data) &gt;= 4:\n                S0, S1, S2 = compute_stokes_components(I_data[0], I_data[1], I_data[2], I_data[3])\n                S1_hat, S2_hat = compute_normalized_stokes(S0, S1, S2)\n                S_m_hat[c, 0] = S1_hat\n                S_m_hat[c, 1] = S2_hat\n\n        # Use Stokes method for initial guess\n        initial_guess, _ = recover_stress_tensor(S_m_hat, wavelengths, C_values, nu, L, S_i_hat)\n\n    # Set bounds if not provided\n    if bounds is None:\n        bounds = (np.array([-1e9, -1e9, -1e9]), np.array([1e9, 1e9, 1e9]))\n\n    # Choose optimization method\n    if method == \"nelder-mead\":\n        # Use Nelder-Mead for robustness (no gradient needed)\n        result = minimize(\n            lambda x: np.sum(\n                compute_intensity_residual(\n                    x,\n                    I_measured,\n                    wavelengths,\n                    C_values,\n                    nu,\n                    L,\n                    analyzer_angles,\n                    S_i_hat,\n                    I0,\n                    weights,\n                )\n                ** 2\n            ),\n            initial_guess,\n            method=\"Nelder-Mead\",\n            options={\"xatol\": 1e-16, \"fatol\": 1e-16, \"maxiter\": 2000},\n        )\n        stress_tensor = result.x\n        success = result.success\n\n    else:\n        # Use least_squares for methods that can exploit Jacobian\n        # Note: 'lm' method doesn't support bounds\n        if method == \"lm\":\n            result = least_squares(\n                compute_intensity_residual,\n                initial_guess,\n                args=(\n                    I_measured,\n                    wavelengths,\n                    C_values,\n                    nu,\n                    L,\n                    analyzer_angles,\n                    S_i_hat,\n                    I0,\n                    weights,\n                ),\n                method=method,\n                ftol=1e-8,\n                xtol=1e-8,\n                max_nfev=1000,\n            )\n        else:\n            result = least_squares(\n                compute_intensity_residual,\n                initial_guess,\n                args=(\n                    I_measured,\n                    wavelengths,\n                    C_values,\n                    nu,\n                    L,\n                    analyzer_angles,\n                    S_i_hat,\n                    I0,\n                    weights,\n                ),\n                method=method,\n                bounds=bounds,\n                ftol=1e-8,\n                xtol=1e-8,\n                max_nfev=1000,\n            )\n        stress_tensor = result.x\n        success = result.success\n\n    return stress_tensor, success, result\n</code></pre>"},{"location":"reference/intensity_solver/#photoelastimetry.solver.intensity_solver.recover_stress_map_intensity","title":"<code>recover_stress_map_intensity(image_stack, wavelengths, C_values, nu, L, S_i_hat, analyzer_angles=None, I0=1.0, use_poisson_weights=True, initial_guess_method='uniform', method='nelder-mead', n_jobs=-1)</code>","text":"<p>Recover full 2D stress tensor map from raw intensity image stack using intensity method.</p> <p>Parameters:</p> Name Type Description Default <code>image_stack</code> <code>ndarray</code> <p>Image stack of shape [H, W, n_wavelengths, n_angles] where: - H, W are image dimensions - n_wavelengths is number of color channels (typically 3 for RGB) - n_angles is number of polarization analyzer angles (typically 4)</p> required <code>wavelengths</code> <code>array - like</code> <p>Wavelengths for each channel (m).</p> required <code>C_values</code> <code>array - like</code> <p>Stress-optic coefficients for each channel (1/Pa).</p> required <code>nu</code> <code>float or ndarray</code> <p>Solid fraction. Use 1.0 for solid samples. Can be scalar or array matching image dimensions [H, W].</p> required <code>L</code> <code>float</code> <p>Sample thickness (m).</p> required <code>analyzer_angles</code> <code>array - like</code> <p>Analyzer angles in radians. Default: [0, \u03c0/4, \u03c0/2, 3\u03c0/4].</p> <code>None</code> <code>S_i_hat</code> <code>array - like</code> <p>Incoming normalized Stokes vector [S1_hat, S2_hat, S3_hat].</p> required <code>I0</code> <code>float</code> <p>Reference incident intensity (default: 1.0).</p> <code>1.0</code> <code>use_poisson_weights</code> <code>bool</code> <p>Whether to use Poisson noise weighting (weight ~ 1/sqrt(I)). Default: True.</p> <code>True</code> <code>initial_guess_method</code> <code>str</code> <p>Method for initial guess: 'stokes' (default) uses Stokes-based solver, 'zero' uses zeros, 'uniform' uses small uniform stress.</p> <code>'uniform'</code> <code>method</code> <code>str</code> <p>Optimization method: 'lm' (default), 'trf', 'dogbox', or 'nelder-mead'.</p> <code>'nelder-mead'</code> <code>n_jobs</code> <code>int</code> <p>Number of parallel jobs. -1 uses all available cores (default: -1).</p> <code>-1</code> <p>Returns:</p> Name Type Description <code>stress_map</code> <code>ndarray</code> <p>Array of shape [H, W, 3] containing [sigma_xx, sigma_yy, sigma_xy] in Pa.</p> <code>success_map</code> <code>ndarray</code> <p>Boolean array of shape [H, W] indicating successful convergence.</p> Notes <p>This is the main function for generating stress maps using intensity-based inversion. It processes each pixel independently and can run in parallel.</p> <p>For most applications, this method is slower but more accurate than the Stokes-based method, especially near degenerate points.</p> Source code in <code>photoelastimetry/solver/intensity_solver.py</code> <pre><code>def recover_stress_map_intensity(\n    image_stack,\n    wavelengths,\n    C_values,\n    nu,\n    L,\n    S_i_hat,\n    analyzer_angles=None,\n    I0=1.0,\n    use_poisson_weights=True,\n    initial_guess_method=\"uniform\",\n    method=\"nelder-mead\",\n    n_jobs=-1,\n):\n    \"\"\"\n    Recover full 2D stress tensor map from raw intensity image stack using intensity method.\n\n    Parameters\n    ----------\n    image_stack : ndarray\n        Image stack of shape [H, W, n_wavelengths, n_angles] where:\n        - H, W are image dimensions\n        - n_wavelengths is number of color channels (typically 3 for RGB)\n        - n_angles is number of polarization analyzer angles (typically 4)\n    wavelengths : array-like\n        Wavelengths for each channel (m).\n    C_values : array-like\n        Stress-optic coefficients for each channel (1/Pa).\n    nu : float or ndarray\n        Solid fraction. Use 1.0 for solid samples.\n        Can be scalar or array matching image dimensions [H, W].\n    L : float\n        Sample thickness (m).\n    analyzer_angles : array-like, optional\n        Analyzer angles in radians. Default: [0, \u03c0/4, \u03c0/2, 3\u03c0/4].\n    S_i_hat : array-like\n        Incoming normalized Stokes vector [S1_hat, S2_hat, S3_hat].\n    I0 : float, optional\n        Reference incident intensity (default: 1.0).\n    use_poisson_weights : bool, optional\n        Whether to use Poisson noise weighting (weight ~ 1/sqrt(I)).\n        Default: True.\n    initial_guess_method : str, optional\n        Method for initial guess: 'stokes' (default) uses Stokes-based solver,\n        'zero' uses zeros, 'uniform' uses small uniform stress.\n    method : str, optional\n        Optimization method: 'lm' (default), 'trf', 'dogbox', or 'nelder-mead'.\n    n_jobs : int, optional\n        Number of parallel jobs. -1 uses all available cores (default: -1).\n\n    Returns\n    -------\n    stress_map : ndarray\n        Array of shape [H, W, 3] containing [sigma_xx, sigma_yy, sigma_xy] in Pa.\n    success_map : ndarray\n        Boolean array of shape [H, W] indicating successful convergence.\n\n    Notes\n    -----\n    This is the main function for generating stress maps using intensity-based\n    inversion. It processes each pixel independently and can run in parallel.\n\n    For most applications, this method is slower but more accurate than the\n    Stokes-based method, especially near degenerate points.\n    \"\"\"\n    from joblib import Parallel, delayed\n\n    if analyzer_angles is None:\n        analyzer_angles = np.array([0, np.pi / 4, np.pi / 2, 3 * np.pi / 4])\n\n    H, W, n_wavelengths, n_angles = image_stack.shape\n    stress_map = np.zeros((H, W, 3), dtype=np.float32)\n    success_map = np.zeros((H, W), dtype=bool)\n\n    # Optionally compute initial guess map using Stokes method\n    initial_guess_map = None\n    if initial_guess_method == \"stokes\":\n        print(\"Computing initial guess using Stokes-based solver...\")\n        from photoelastimetry.solver.stokes_solver import recover_stress_map_stokes\n\n        initial_guess_map = recover_stress_map_stokes(\n            image_stack,\n            wavelengths,\n            C_values,\n            nu,\n            L,\n            S_i_hat,\n            n_jobs=n_jobs,\n        )\n\n    def process_pixel(y, x):\n        \"\"\"Process a single pixel.\"\"\"\n        # Extract intensities for this pixel\n        I_measured = image_stack[y, x, :, :]  # shape: (n_wavelengths, n_angles)\n\n        # Skip if any NaN values\n        if np.isnan(I_measured).any():\n            return (y, x, np.array([np.nan, np.nan, np.nan]), False)\n\n        # Compute weights for Poisson noise if requested\n        weights = None\n        if use_poisson_weights:\n            # Weight = 1/sqrt(I) for Poisson, but avoid division by zero\n            I_safe = np.maximum(I_measured, 1e-6)\n            weights = 1.0 / np.sqrt(I_safe)\n\n        # Get solid fraction for this pixel\n        nu_pixel = nu if np.isscalar(nu) else nu[y, x]\n\n        # Get initial guess\n        if initial_guess_map is not None:\n            initial_guess = initial_guess_map[y, x, :]\n        elif initial_guess_method == \"uniform\":\n            initial_guess = np.array([1e6, 1e6, 0.0])\n        else:  # zero\n            initial_guess = np.array([0.0, 0.0, 0.0])\n\n        # Recover stress tensor\n        stress_tensor, success, _ = recover_stress_tensor_intensity(\n            I_measured,\n            wavelengths,\n            C_values,\n            nu_pixel,\n            L,\n            S_i_hat,\n            analyzer_angles,\n            I0,\n            weights,\n            initial_guess,\n            method,\n        )\n\n        return (y, x, stress_tensor, success)\n\n    # Create list of pixel coordinates\n    pixel_coords = [(y, x) for y in range(H) for x in range(W)]\n\n    # Process pixels in parallel\n    print(f\"Processing {H}\u00d7{W} = {H*W} pixels with intensity-based solver...\")\n    results = Parallel(n_jobs=n_jobs)(\n        delayed(process_pixel)(y, x) for y, x in tqdm(pixel_coords, desc=\"Intensity inversion\")\n    )\n\n    # Fill in the stress map\n    for y, x, stress_tensor, success in results:\n        stress_map[y, x, :] = stress_tensor\n        success_map[y, x] = success\n\n    success_rate = np.sum(success_map) / (H * W) * 100\n    print(f\"Success rate: {success_rate:.1f}%\")\n\n    return stress_map, success_map\n</code></pre>"},{"location":"reference/intensity_solver/#photoelastimetry.solver.intensity_solver.compare_stokes_vs_intensity","title":"<code>compare_stokes_vs_intensity(image_stack, wavelengths, C_values, nu, L, S_i_hat, analyzer_angles=None, true_stress=None)</code>","text":"<p>Compare Stokes-based and intensity-based inversion methods.</p> <p>This utility function runs both methods on the same data and provides comparison metrics. Useful for validation and understanding trade-offs.</p> <p>Parameters:</p> Name Type Description Default <code>image_stack</code> <code>ndarray</code> <p>Image stack [H, W, n_wavelengths, n_angles].</p> required <code>wavelengths</code> <code>array - like</code> <p>Wavelengths for each channel (m).</p> required <code>C_values</code> <code>array - like</code> <p>Stress-optic coefficients (1/Pa).</p> required <code>nu</code> <code>float or ndarray</code> <p>Solid fraction.</p> required <code>L</code> <code>float</code> <p>Sample thickness (m).</p> required <code>analyzer_angles</code> <code>array - like</code> <p>Analyzer angles in radians.</p> <code>None</code> <code>S_i_hat</code> <code>array - like</code> <p>Incoming normalized Stokes vector [S1_hat, S2_hat, S3_hat].</p> required <code>true_stress</code> <code>ndarray</code> <p>Ground truth stress field [H, W, 3] for validation.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>results</code> <code>dict</code> <p>Dictionary containing: - 'stokes_stress': Stokes solver result [H, W, 3] - 'intensity_stress': Intensity solver result [H, W, 3] - 'stokes_success_rate': Convergence rate for Stokes - 'intensity_success_rate': Convergence rate for intensity - 'stokes_residual': Mean residual for Stokes - 'intensity_residual': Mean residual for intensity - 'stokes_error': RMSE vs truth (if provided) - 'intensity_error': RMSE vs truth (if provided) - 'runtime_stokes': Execution time for Stokes - 'runtime_intensity': Execution time for intensity</p> Source code in <code>photoelastimetry/solver/intensity_solver.py</code> <pre><code>def compare_stokes_vs_intensity(\n    image_stack,\n    wavelengths,\n    C_values,\n    nu,\n    L,\n    S_i_hat,\n    analyzer_angles=None,\n    true_stress=None,\n):\n    \"\"\"\n    Compare Stokes-based and intensity-based inversion methods.\n\n    This utility function runs both methods on the same data and provides\n    comparison metrics. Useful for validation and understanding trade-offs.\n\n    Parameters\n    ----------\n    image_stack : ndarray\n        Image stack [H, W, n_wavelengths, n_angles].\n    wavelengths : array-like\n        Wavelengths for each channel (m).\n    C_values : array-like\n        Stress-optic coefficients (1/Pa).\n    nu : float or ndarray\n        Solid fraction.\n    L : float\n        Sample thickness (m).\n    analyzer_angles : array-like, optional\n        Analyzer angles in radians.\n    S_i_hat : array-like\n        Incoming normalized Stokes vector [S1_hat, S2_hat, S3_hat].\n    true_stress : ndarray, optional\n        Ground truth stress field [H, W, 3] for validation.\n\n    Returns\n    -------\n    results : dict\n        Dictionary containing:\n        - 'stokes_stress': Stokes solver result [H, W, 3]\n        - 'intensity_stress': Intensity solver result [H, W, 3]\n        - 'stokes_success_rate': Convergence rate for Stokes\n        - 'intensity_success_rate': Convergence rate for intensity\n        - 'stokes_residual': Mean residual for Stokes\n        - 'intensity_residual': Mean residual for intensity\n        - 'stokes_error': RMSE vs truth (if provided)\n        - 'intensity_error': RMSE vs truth (if provided)\n        - 'runtime_stokes': Execution time for Stokes\n        - 'runtime_intensity': Execution time for intensity\n    \"\"\"\n    import time\n\n    from photoelastimetry.solver.stokes_solver import recover_stress_map_stokes\n\n    print(\"=== Running Stokes-based Solver ===\")\n    t0 = time.time()\n    stress_stokes = recover_stress_map_stokes(image_stack, wavelengths, C_values, nu, L, S_i_hat, n_jobs=-1)\n    t_stokes = time.time() - t0\n    print(f\"Completed in {t_stokes:.2f} seconds\")\n\n    print(\"\\n=== Running Intensity-based Solver ===\")\n    t0 = time.time()\n    stress_intensity, success_map = recover_stress_map_intensity(\n        image_stack,\n        wavelengths,\n        C_values,\n        nu,\n        L,\n        analyzer_angles,\n        S_i_hat,\n        use_poisson_weights=True,\n        initial_guess_method=\"stokes\",\n        n_jobs=-1,\n    )\n    t_intensity = time.time() - t0\n    print(f\"Completed in {t_intensity:.2f} seconds\")\n\n    # Compute success rates\n    stokes_success_rate = (\n        np.sum(~np.isnan(stress_stokes[:, :, 0])) / stress_stokes.shape[0] / stress_stokes.shape[1] * 100\n    )\n    intensity_success_rate = np.sum(success_map) / success_map.size * 100\n\n    results = {\n        \"stokes_stress\": stress_stokes,\n        \"intensity_stress\": stress_intensity,\n        \"stokes_success_rate\": stokes_success_rate,\n        \"intensity_success_rate\": intensity_success_rate,\n        \"runtime_stokes\": t_stokes,\n        \"runtime_intensity\": t_intensity,\n    }\n\n    # Compute errors vs ground truth if provided\n    if true_stress is not None:\n        stokes_error = np.sqrt(np.nanmean((stress_stokes - true_stress) ** 2))\n        intensity_error = np.sqrt(np.nanmean((stress_intensity - true_stress) ** 2))\n        results[\"stokes_error\"] = stokes_error\n        results[\"intensity_error\"] = intensity_error\n\n        print(f\"\\n=== Comparison Results ===\")\n        print(f\"Stokes RMSE vs truth: {stokes_error:.3e} Pa\")\n        print(f\"Intensity RMSE vs truth: {intensity_error:.3e} Pa\")\n        print(f\"Improvement: {(1 - intensity_error/stokes_error)*100:.1f}%\")\n\n    print(f\"\\nStokes success rate: {stokes_success_rate:.1f}%\")\n    print(f\"Intensity success rate: {intensity_success_rate:.1f}%\")\n    print(f\"Stokes runtime: {t_stokes:.2f} s\")\n    print(f\"Intensity runtime: {t_intensity:.2f} s\")\n    print(f\"Speedup: {t_stokes/t_intensity:.2f}x\")\n\n    return results\n</code></pre>"},{"location":"reference/io/","title":"io","text":"<p>Input/output operations for images and data.</p> <p>This module handles reading and writing of image files, raw camera data, and parameter files for photoelastic analysis workflows.</p>"},{"location":"reference/io/#photoelastimetry.io","title":"<code>io</code>","text":""},{"location":"reference/io/#photoelastimetry.io-functions","title":"Functions","text":""},{"location":"reference/io/#photoelastimetry.io.split_channels","title":"<code>split_channels(data)</code>","text":"<p>Splits the data into its respective polarisation channels. Each superpixel is 4x4 pixels, and the channels are arranged in the following order:</p> <p>R_0 | R_45 | G1_0 | G1_45 R_135 | R_90 | G1_135 | G1_90 G2_0 | G2_45 | B_0 | B_45 G2_135 | G2_90 | B_135 | B_90</p> Source code in <code>photoelastimetry/io.py</code> <pre><code>def split_channels(data):\n    \"\"\"\n    Splits the data into its respective polarisation channels. Each superpixel\n    is 4x4 pixels, and the channels are arranged in the following order:\n\n    R_0 | R_45 | G1_0 | G1_45\n    R_135 | R_90 | G1_135 | G1_90\n    G2_0 | G2_45 | B_0 | B_45\n    G2_135 | G2_90 | B_135 | B_90\n    \"\"\"\n\n    # Reshape the data into a 4D array\n    R_0 = data[0::4, 0::4]\n    R_45 = data[0::4, 1::4]\n    G1_0 = data[0::4, 2::4]\n    G1_45 = data[0::4, 3::4]\n    R_135 = data[1::4, 0::4]\n    R_90 = data[1::4, 1::4]\n    G1_135 = data[1::4, 2::4]\n    G1_90 = data[1::4, 3::4]\n    G2_0 = data[2::4, 0::4]\n    G2_45 = data[2::4, 1::4]\n    B_0 = data[2::4, 2::4]\n    B_45 = data[2::4, 3::4]\n    G2_135 = data[3::4, 0::4]\n    G2_90 = data[3::4, 1::4]\n    B_135 = data[3::4, 2::4]\n    B_90 = data[3::4, 3::4]\n\n    # Stack the channels into a 4D array\n    I0 = np.stack((R_0, G1_0, G2_0, B_0), axis=-1)\n    I90 = np.stack((R_90, G1_90, G2_90, B_90), axis=-1)\n    I45 = np.stack((R_45, G1_45, G2_45, B_45), axis=-1)\n    I135 = np.stack((R_135, G1_135, G2_135, B_135), axis=-1)\n\n    # data is a 4D array with shape (height, width, colour, polarisation)\n    data = np.stack(\n        (\n            I0,\n            I45,\n            I90,\n            I135,\n        ),\n        axis=-1,\n    )\n    return data\n</code></pre>"},{"location":"reference/io/#photoelastimetry.io.save_image","title":"<code>save_image(filename, data, metadata={})</code>","text":"<p>Save image data to a file in various formats.</p> <p>This function saves image data to disk in one of several supported formats, automatically determining the format from the file extension.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the output file. The file extension determines the format. Supported extensions: .npy, .raw, .png, .jpg, .jpeg, .tiff, .tif</p> required <code>data</code> <code>ndarray</code> <p>Image data to save. The data will be cast to the appropriate dtype based on the file format (uint8 for .png/.jpg, uint16 for .tiff, etc.)</p> required <code>metadata</code> <code>dict</code> <p>Dictionary containing metadata about the image. For .raw format, must contain a \"dtype\" key specifying the data type to use when saving. Default is empty.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file extension is not one of the supported formats.</p> Notes <ul> <li>.npy files preserve the original data type and shape</li> <li>.raw files are saved as binary with dtype specified in metadata</li> <li>.png and .jpg files convert data to uint8</li> <li>.tiff/.tif files convert data to uint16</li> <li>matplotlib is used for .png and .jpg formats</li> <li>tifffile library is used for .tiff/.tif formats</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data = np.random.randint(0, 255, (100, 100), dtype=np.uint8)\n&gt;&gt;&gt; metadata = {\"dtype\": \"uint8\"}\n&gt;&gt;&gt; save_image(\"output.png\", data, metadata)\n</code></pre> Source code in <code>photoelastimetry/io.py</code> <pre><code>def save_image(filename, data, metadata={}):\n    \"\"\"\n    Save image data to a file in various formats.\n\n    This function saves image data to disk in one of several supported formats,\n    automatically determining the format from the file extension.\n\n    Parameters\n    ----------\n    filename : str\n        Path to the output file. The file extension determines the format.\n        Supported extensions: .npy, .raw, .png, .jpg, .jpeg, .tiff, .tif\n    data : numpy.ndarray\n        Image data to save. The data will be cast to the appropriate dtype\n        based on the file format (uint8 for .png/.jpg, uint16 for .tiff, etc.)\n    metadata : dict\n        Dictionary containing metadata about the image. For .raw format, must\n        contain a \"dtype\" key specifying the data type to use when saving. Default is empty.\n\n    Raises\n    ------\n    ValueError\n        If the file extension is not one of the supported formats.\n\n    Notes\n    -----\n    - .npy files preserve the original data type and shape\n    - .raw files are saved as binary with dtype specified in metadata\n    - .png and .jpg files convert data to uint8\n    - .tiff/.tif files convert data to uint16\n    - matplotlib is used for .png and .jpg formats\n    - tifffile library is used for .tiff/.tif formats\n\n    Examples\n    --------\n    &gt;&gt;&gt; data = np.random.randint(0, 255, (100, 100), dtype=np.uint8)\n    &gt;&gt;&gt; metadata = {\"dtype\": \"uint8\"}\n    &gt;&gt;&gt; save_image(\"output.png\", data, metadata)\n    \"\"\"\n    output_folder = os.path.dirname(filename)\n    if output_folder != \"\" and not os.path.exists(output_folder):\n        os.makedirs(output_folder)\n\n    if filename.endswith(\".npy\"):\n        np.save(filename, data)\n    elif filename.endswith(\".raw\"):\n        with open(filename, \"wb\") as f:\n            data.astype(metadata[\"dtype\"]).tofile(f)\n    elif filename.endswith(\".png\"):\n        import matplotlib.pyplot as plt\n\n        plt.imsave(filename, data.astype(np.uint8))\n    elif filename.endswith(\".jpg\") or filename.endswith(\".jpeg\"):\n        import matplotlib.pyplot as plt\n\n        plt.imsave(filename, data.astype(np.uint8))\n    elif filename.endswith(\".tiff\") or filename.endswith(\".tif\"):\n        import tifffile\n\n        if data.ndim == 2:\n            tifffile.imwrite(filename, data.astype(\"&lt;f4\"))\n        elif data.ndim == 3:\n            transposed = np.transpose(data, (2, 0, 1))\n            tifffile.imwrite(filename, transposed.astype(\"&lt;f4\"), imagej=True, metadata={\"axes\": \"CYX\"})\n        elif data.ndim == 4:\n            # Permute to [4, 3, H, W] so TIFF is interpreted as 4 timepoints of 3-channel images\n            transposed = np.transpose(data, (3, 2, 0, 1))\n            tifffile.imwrite(filename, transposed.astype(\"&lt;f4\"), imagej=True, metadata={\"axes\": \"TCYX\"})\n    else:\n        raise ValueError(\n            f\"Unsupported file format for {filename}. Supported formats are .npy, .raw, .png, .jpg, .jpeg, .tiff, .tif\"\n        )\n</code></pre>"},{"location":"reference/io/#photoelastimetry.io.load_image","title":"<code>load_image(filename, metadata=None)</code>","text":"<p>Load image data from a file in various formats.</p> <p>This function loads image data from disk in one of several supported formats, automatically determining the format from the file extension.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the input file. The file extension determines the format. Supported extensions: .npy, .raw, .png, .jpg, .jpeg, .tiff, .tif</p> required <code>metadata</code> <code>dict</code> <p>Dictionary containing metadata about the image. For .raw format, must contain \"width\", \"height\", and \"dtype\" keys specifying the image dimensions and data type. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Loaded image data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file extension is not one of the supported formats.</p> Notes <ul> <li>.npy files preserve the original data type and shape</li> <li>.raw files are read as binary with dtype and shape specified in metadata</li> <li>.png and .jpg files are loaded as uint8 arrays</li> <li>.tiff/.tif files are loaded as uint16 arrays</li> <li>matplotlib is used for .png and .jpg formats</li> <li>tifffile library is used for .tiff/.tif formats</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; metadata = {\"width\": 100, \"height\": 100, \"dtype\": \"uint8\"}\n&gt;&gt;&gt; data = load_image(\"input.raw\", metadata)\n</code></pre> Source code in <code>photoelastimetry/io.py</code> <pre><code>def load_image(filename, metadata=None):\n    \"\"\"\n    Load image data from a file in various formats.\n\n    This function loads image data from disk in one of several supported formats,\n    automatically determining the format from the file extension.\n\n    Parameters\n    ----------\n    filename : str\n        Path to the input file. The file extension determines the format.\n        Supported extensions: .npy, .raw, .png, .jpg, .jpeg, .tiff, .tif\n    metadata : dict, optional\n        Dictionary containing metadata about the image. For .raw format, must\n        contain \"width\", \"height\", and \"dtype\" keys specifying the image dimensions\n        and data type. Default is None.\n\n    Returns\n    -------\n    numpy.ndarray\n        Loaded image data.\n\n    Raises\n    ------\n    ValueError\n        If the file extension is not one of the supported formats.\n\n    Notes\n    -----\n    - .npy files preserve the original data type and shape\n    - .raw files are read as binary with dtype and shape specified in metadata\n    - .png and .jpg files are loaded as uint8 arrays\n    - .tiff/.tif files are loaded as uint16 arrays\n    - matplotlib is used for .png and .jpg formats\n    - tifffile library is used for .tiff/.tif formats\n\n    Examples\n    --------\n    &gt;&gt;&gt; metadata = {\"width\": 100, \"height\": 100, \"dtype\": \"uint8\"}\n    &gt;&gt;&gt; data = load_image(\"input.raw\", metadata)\n    \"\"\"\n    if filename.endswith(\".npy\"):\n        data = np.load(filename)\n    elif filename.endswith(\".raw\"):\n        with open(filename, \"rb\") as f:\n            data = np.memmap(\n                f,\n                dtype=metadata[\"dtype\"],\n                mode=\"r\",\n                offset=0,\n                shape=(metadata[\"height\"], metadata[\"width\"]),\n            )\n            data = np.array(data)\n    elif filename.endswith(\".png\") or filename.endswith(\".jpg\") or filename.endswith(\".jpeg\"):\n        import matplotlib.pyplot as plt\n\n        data = plt.imread(filename)\n    elif filename.endswith(\".tiff\") or filename.endswith(\".tif\"):\n        import tifffile\n\n        data = tifffile.imread(filename)\n\n        # transpose data to XYC or XYCP format\n        if data.ndim == 3:\n            data = np.transpose(data, (1, 2, 0))\n        elif data.ndim == 4:\n            data = np.transpose(data, (2, 3, 1, 0))\n\n    else:\n        raise ValueError(\n            f\"Unsupported file format for {filename}. Supported formats are .npy, .raw, .png, .jpg, .jpeg, .tiff, .tif\"\n        )\n\n    if metadata is None:\n        metadata = {}\n        metadata[\"dtype\"] = str(data.dtype)\n        metadata[\"height\"] = data.shape[0]\n        metadata[\"width\"] = data.shape[1]\n\n    return data, metadata\n</code></pre>"},{"location":"reference/io/#photoelastimetry.io.bin_image","title":"<code>bin_image(data, binning)</code>","text":"<p>Bin the image by the specified factor.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input image data to be binned.</p> required <code>binning</code> <code>int</code> <p>Binning factor. The image dimensions will be reduced by this factor.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Binned image data.</p> Source code in <code>photoelastimetry/io.py</code> <pre><code>def bin_image(data, binning):\n    \"\"\"\n    Bin the image by the specified factor.\n\n    Parameters\n    ----------\n    data : numpy.ndarray\n        Input image data to be binned.\n    binning : int\n        Binning factor. The image dimensions will be reduced by this factor.\n\n    Returns\n    -------\n    numpy.ndarray\n        Binned image data.\n    \"\"\"\n    if binning &lt;= 1:\n        return data\n\n    # Calculate new shape\n    new_height = data.shape[0] // binning\n    new_width = data.shape[1] // binning\n\n    # Reshape and bin\n    binned_data = (\n        data[: new_height * binning, : new_width * binning]\n        .reshape(new_height, binning, new_width, binning, *data.shape[2:])\n        .mean(axis=(1, 3))\n    )\n\n    return binned_data\n</code></pre>"},{"location":"reference/main/","title":"main","text":"<p>Command-line interface entry points.</p> <p>This module provides the command-line interfaces for the three main tools: - <code>image-to-stress</code> - Convert photoelastic images to stress maps - <code>stress-to-image</code> - Generate photoelastic images from stress fields - <code>demosaic-raw</code> - Process raw polarimetric camera images</p>"},{"location":"reference/main/#photoelastimetry.main","title":"<code>main</code>","text":""},{"location":"reference/main/#photoelastimetry.main-functions","title":"Functions","text":""},{"location":"reference/main/#photoelastimetry.main.image_to_stress","title":"<code>image_to_stress(params, output_filename=None)</code>","text":"<p>Convert photoelastic images to stress maps.</p> <p>This function processes raw photoelastic data to recover stress distribution maps using the stress-optic law and polarization analysis.</p> <p>Args:     params (dict): Configuration dictionary containing:         - input_filename (str, optional): Path to input image file. If None, raw images are loaded from folderName.         - folderName (str): Path to folder containing raw photoelastic images         - crop (list, optional): Crop region as [x1, x2, y1, y2]         - debug (bool): If True, display all channels for debugging         - C (float): Stress-optic coefficient in 1/Pa         - thickness (float): Sample thickness in meters         - wavelengths (list): List of wavelengths in nanometers         - S_i_hat (list): Incoming normalized Stokes vector [S1_hat, S2_hat, S3_hat]     output_filename (str, optional): Path to save the output stress map image.         If None, the stress map is not saved. Defaults to None. Can also be specified in params.</p> <p>Returns:     numpy.ndarray: 2D array representing the stress map in Pascals.</p> <p>Notes:     - Assumes incoming light is fully S1 polarized     - Uses uniform stress-optic coefficient across all wavelengths     - Assumes solid sample (NU = 1.0)     - Wavelengths are automatically converted from nm to meters</p> Source code in <code>photoelastimetry/main.py</code> <pre><code>def image_to_stress(params, output_filename=None):\n    \"\"\"\n    Convert photoelastic images to stress maps.\n\n    This function processes raw photoelastic data to recover stress distribution maps\n    using the stress-optic law and polarization analysis.\n\n    Args:\n        params (dict): Configuration dictionary containing:\n            - input_filename (str, optional): Path to input image file. If None, raw images are loaded from folderName.\n            - folderName (str): Path to folder containing raw photoelastic images\n            - crop (list, optional): Crop region as [x1, x2, y1, y2]\n            - debug (bool): If True, display all channels for debugging\n            - C (float): Stress-optic coefficient in 1/Pa\n            - thickness (float): Sample thickness in meters\n            - wavelengths (list): List of wavelengths in nanometers\n            - S_i_hat (list): Incoming normalized Stokes vector [S1_hat, S2_hat, S3_hat]\n        output_filename (str, optional): Path to save the output stress map image.\n            If None, the stress map is not saved. Defaults to None. Can also be specified in params.\n\n    Returns:\n        numpy.ndarray: 2D array representing the stress map in Pascals.\n\n    Notes:\n        - Assumes incoming light is fully S1 polarized\n        - Uses uniform stress-optic coefficient across all wavelengths\n        - Assumes solid sample (NU = 1.0)\n        - Wavelengths are automatically converted from nm to meters\n    \"\"\"\n\n    if \"folderName\" in params:\n        data, metadata = photoelastimetry.io.load_raw(params[\"folderName\"])\n    elif \"input_filename\" in params:\n        data, metadata = photoelastimetry.io.load_image(params[\"input_filename\"])\n    else:\n        raise ValueError(\"Either 'folderName' or 'input_filename' must be specified in params.\")\n\n    if params.get(\"crop\") is not None:\n        data = data[\n            params[\"crop\"][2] : params[\"crop\"][3],\n            params[\"crop\"][0] : params[\"crop\"][1],\n            :,\n            :,\n        ]\n        if params[\"debug\"]:\n            photoelastimetry.io.save_image(\"debug_cropped_image.tiff\", data, metadata)\n\n    if params[\"debug\"]:\n        import matplotlib.pyplot as plt\n        import tifffile\n\n        tifffile.imwrite(\"debug_before_binning.tiff\", data[:, :, 0, 0])\n\n    if params.get(\"binning\") is not None:\n        binning = params[\"binning\"]\n        data = photoelastimetry.io.bin_image(data, binning)\n        metadata[\"height\"] //= binning\n        metadata[\"width\"] //= binning\n\n    if params[\"debug\"]:\n        photoelastimetry.plotting.show_all_channels(data, metadata)\n\n    C = params[\"C\"]  # Stress-optic coefficients in 1/Pa\n    L = params[\"thickness\"]  # Thickness in m\n    WAVELENGTHS = np.array(params[\"wavelengths\"]) * 1e-9  # Wavelengths in m\n    NU = 1.0  # Solid sample\n    if isinstance(C, list) or isinstance(C, np.ndarray):\n        C_VALUES = C\n    else:\n        C_VALUES = [\n            C,\n            C,\n            C,\n        ]  # Stress-optic coefficients in 1/Pa\n\n    # Get incoming polarization state from config\n    S_I_HAT = np.array(params[\"S_i_hat\"])\n    # Ensure it's 3 elements for consistency\n    if len(S_I_HAT) == 2:\n        S_I_HAT = np.append(S_I_HAT, 0.0)  # Add S3_hat = 0 for backward compatibility\n\n    # Calculate stress map from image\n    n_jobs = params.get(\"n_jobs\", -1)  # Default to using all cores\n    if params.get(\"solver\") == \"stokes\":\n        stress_map = photoelastimetry.solver.stokes_solver.recover_stress_map_stokes(\n            data,\n            WAVELENGTHS,\n            C_VALUES,\n            NU,\n            L,\n            S_I_HAT,\n            n_jobs=n_jobs,\n        )\n    elif params.get(\"solver\") == \"intensity\":\n        stress_map, success_map = photoelastimetry.solver.intensity_solver.recover_stress_map_intensity(\n            data,\n            WAVELENGTHS,\n            C_VALUES,\n            NU,\n            L,\n            S_I_HAT,\n            n_jobs=n_jobs,\n        )\n    elif params.get(\"solver\") == \"equilibrium\":\n        stress_map = photoelastimetry.solver.equilibrium_solver.recover_stress_field_global_iterative(\n            data,\n            WAVELENGTHS,\n            C_VALUES,\n            NU,\n            L,\n            S_I_HAT,\n            n_jobs=n_jobs,\n        )\n    else:\n        raise ValueError(\"Solver type not recognized. Use 'stokes', 'intensity', or 'equilibrium'.\")\n\n    if params.get(\"output_filename\") is not None:\n        output_filename = params[\"output_filename\"]\n\n    if output_filename is not None:\n        photoelastimetry.io.save_image(output_filename, stress_map, metadata)\n\n    return stress_map\n</code></pre>"},{"location":"reference/main/#photoelastimetry.main.stress_to_image","title":"<code>stress_to_image(params)</code>","text":"<p>Convert stress field data to photoelastic fringe pattern image.</p> <p>This function loads stress field data, optionally applies Gaussian scattering, computes principal stresses and their orientations, calculates photoelastic retardation and fringe patterns, and saves the resulting visualization.</p> <p>Args:     params (dict): Dictionary containing the following keys:         - p_filename (str): Path to the photoelastimetry parameter file         - stress_filename (str): Path to the stress field data file         - scattering (float, optional): Gaussian filter sigma for scattering simulation.           If falsy, no scattering is applied.         - t (float): Thickness of the photoelastic material         - lambda_light (float): Wavelength of light used in the experiment         - C (float): Stress-optic coefficient of the material         - output_filename (str, optional): Path for the output image.           Defaults to \"output.png\" if not provided.</p> <p>Returns:     None: The function saves the fringe pattern visualization to a file.</p> <p>Notes:     - The stress field is expected to have components in the order [sigma_xy, sigma_yy, sigma_xx]     - Principal stresses are computed using Mohr's circle equations     - Isochromatic fringe intensity is calculated using sin\u00b2(\u03b4/2)     - Isoclinic angle represents the orientation of principal stresses</p> Source code in <code>photoelastimetry/main.py</code> <pre><code>def stress_to_image(params):\n    \"\"\"\n    Convert stress field data to photoelastic fringe pattern image.\n\n    This function loads stress field data, optionally applies Gaussian scattering,\n    computes principal stresses and their orientations, calculates photoelastic\n    retardation and fringe patterns, and saves the resulting visualization.\n\n    Args:\n        params (dict): Dictionary containing the following keys:\n            - p_filename (str): Path to the photoelastimetry parameter file\n            - stress_filename (str): Path to the stress field data file\n            - scattering (float, optional): Gaussian filter sigma for scattering simulation.\n              If falsy, no scattering is applied.\n            - t (float): Thickness of the photoelastic material\n            - lambda_light (float): Wavelength of light used in the experiment\n            - C (float): Stress-optic coefficient of the material\n            - output_filename (str, optional): Path for the output image.\n              Defaults to \"output.png\" if not provided.\n\n    Returns:\n        None: The function saves the fringe pattern visualization to a file.\n\n    Notes:\n        - The stress field is expected to have components in the order [sigma_xy, sigma_yy, sigma_xx]\n        - Principal stresses are computed using Mohr's circle equations\n        - Isochromatic fringe intensity is calculated using sin\u00b2(\u03b4/2)\n        - Isoclinic angle represents the orientation of principal stresses\n    \"\"\"\n\n    with open(params[\"p_filename\"]) as f:\n        dict, p = photoelastimetry.io.load_file(f)\n\n    sigma = photoelastimetry.io.load_image(params[\"stress_filename\"], dict)\n\n    sigma_xx = sigma[:, :, 2]\n    sigma_xy = sigma[:, :, 0]\n    sigma_yy = sigma[:, :, 1]\n\n    if params[\"scattering\"]:\n        # Add scattering\n        sigma_xx = gaussian_filter(sigma_xx, sigma=params[\"scattering\"])\n        sigma_xy = gaussian_filter(sigma_xy, sigma=params[\"scattering\"])\n        sigma_yy = gaussian_filter(sigma_yy, sigma=params[\"scattering\"])\n\n    # Compute principal stresses\n    sigma_avg = (sigma_xx + sigma_yy) / 2\n    R = np.sqrt(((sigma_xx - sigma_yy) / 2) ** 2 + sigma_xy**2)\n    sigma_1 = sigma_avg + R\n    sigma_2 = sigma_avg - R\n\n    # Stress difference and retardation\n    delta_sigma = sigma_1 - sigma_2\n\n    # Retardation\n    delta = (2 * np.pi * params[\"t\"] / params[\"lambda_light\"]) * params[\"C\"] * delta_sigma\n\n    # Fringe order\n    # N = delta / (2 * np.pi)\n\n    # Visualize Isochromatic Fringe Pattern\n    fringe_intensity = np.sin(delta / 2) ** 2  # Fringe pattern\n\n    # Isoclinic angle (principal stress orientation)\n    phi = 0.5 * np.arctan2(2 * sigma_xy, sigma_xx - sigma_yy)  # Angle in radians\n\n    # Plot the results\n    if \"output_filename\" in params:\n        output_filename = params[\"output_filename\"]\n    else:\n        output_filename = \"output.png\"\n    photoelastimetry.plotting.plot_fringe_pattern(fringe_intensity, phi, filename=output_filename)\n</code></pre>"},{"location":"reference/main/#photoelastimetry.main.cli_image_to_stress","title":"<code>cli_image_to_stress()</code>","text":"<p>Command line interface for image_to_stress function.</p> Source code in <code>photoelastimetry/main.py</code> <pre><code>def cli_image_to_stress():\n    \"\"\"Command line interface for image_to_stress function.\"\"\"\n    parser = argparse.ArgumentParser(description=\"Convert photoelastic images to stress maps.\")\n    parser.add_argument(\n        \"json_filename\",\n        type=str,\n        help=\"Path to the JSON5 parameter file.\",\n    )\n    parser.add_argument(\n        \"--output\",\n        type=str,\n        default=None,\n        help=\"Path to save the output stress map image (optional).\",\n    )\n    args = parser.parse_args()\n\n    params = json5.load(open(args.json_filename, \"r\"))\n    image_to_stress(params, output_filename=args.output)\n</code></pre>"},{"location":"reference/main/#photoelastimetry.main.cli_stress_to_image","title":"<code>cli_stress_to_image()</code>","text":"<p>Command line interface for stress_to_image function.</p> Source code in <code>photoelastimetry/main.py</code> <pre><code>def cli_stress_to_image():\n    \"\"\"Command line interface for stress_to_image function.\"\"\"\n    parser = argparse.ArgumentParser(\n        description=\"Convert stress field data to photoelastic fringe pattern image.\"\n    )\n    parser.add_argument(\n        \"json_filename\",\n        type=str,\n        help=\"Path to the JSON5 parameter file.\",\n    )\n    args = parser.parse_args()\n\n    params = json5.load(open(args.json_filename, \"r\"))\n    stress_to_image(params)\n</code></pre>"},{"location":"reference/main/#photoelastimetry.main.demosaic_raw_image","title":"<code>demosaic_raw_image(input_file, metadata, output_prefix=None, output_format='tiff')</code>","text":"<p>De-mosaic a raw polarimetric image and save to TIFF stack or individual PNGs.</p> <p>This function takes a raw image from a polarimetric camera with a 4x4 superpixel pattern and splits it into separate channels for each color and polarization angle.</p> <p>Args:     input_file (str): Path to the raw image file.     metadata (dict): Dictionary containing image metadata with keys:         - width (int): Image width in pixels         - height (int): Image height in pixels         - dtype (str, optional): Data type ('uint8' or 'uint16')     output_prefix (str, optional): Prefix for output files. If None, uses input         filename without extension. Defaults to None.     output_format (str, optional): Output format, either 'tiff' for a single         TIFF stack or 'png' for individual PNG files. Defaults to 'tiff'.</p> <p>Returns:     numpy.ndarray: De-mosaiced image stack of shape [H, W, 4, 4] where:         - H, W are the de-mosaiced dimensions (1/4 of original)         - First dimension 4: color channels (R, G1, G2, B)         - Second dimension 4: polarization angles (0\u00b0, 45\u00b0, 90\u00b0, 135\u00b0)</p> <p>Notes:     - The raw image uses a 4x4 superpixel pattern with interleaved polarization       and color filters     - Output TIFF stack has shape [H, W, 4, 4] with all channels     - Output PNGs create 4 files (one per polarization angle) with shape [H, W, 4]       showing all color channels</p> Source code in <code>photoelastimetry/main.py</code> <pre><code>def demosaic_raw_image(input_file, metadata, output_prefix=None, output_format=\"tiff\"):\n    \"\"\"\n    De-mosaic a raw polarimetric image and save to TIFF stack or individual PNGs.\n\n    This function takes a raw image from a polarimetric camera with a 4x4 superpixel\n    pattern and splits it into separate channels for each color and polarization angle.\n\n    Args:\n        input_file (str): Path to the raw image file.\n        metadata (dict): Dictionary containing image metadata with keys:\n            - width (int): Image width in pixels\n            - height (int): Image height in pixels\n            - dtype (str, optional): Data type ('uint8' or 'uint16')\n        output_prefix (str, optional): Prefix for output files. If None, uses input\n            filename without extension. Defaults to None.\n        output_format (str, optional): Output format, either 'tiff' for a single\n            TIFF stack or 'png' for individual PNG files. Defaults to 'tiff'.\n\n    Returns:\n        numpy.ndarray: De-mosaiced image stack of shape [H, W, 4, 4] where:\n            - H, W are the de-mosaiced dimensions (1/4 of original)\n            - First dimension 4: color channels (R, G1, G2, B)\n            - Second dimension 4: polarization angles (0\u00b0, 45\u00b0, 90\u00b0, 135\u00b0)\n\n    Notes:\n        - The raw image uses a 4x4 superpixel pattern with interleaved polarization\n          and color filters\n        - Output TIFF stack has shape [H, W, 4, 4] with all channels\n        - Output PNGs create 4 files (one per polarization angle) with shape [H, W, 4]\n          showing all color channels\n    \"\"\"\n    # Read raw image\n    data = photoelastimetry.io.read_raw(input_file, metadata)\n\n    # De-mosaic into channels\n    demosaiced = photoelastimetry.io.split_channels(data)\n\n    # Keep only R, G1, B channels by removing G2\n    demosaiced = demosaiced[:, :, [0, 1, 3], :]  # Keep R, G1, B\n\n    # Determine output filename prefix\n    if output_prefix is None:\n        output_prefix = os.path.splitext(input_file)[0]\n\n    # Save based on format\n    if output_format.lower() == \"tiff\":\n        import tifffile\n\n        output_file = f\"{output_prefix}_demosaiced.tiff\"\n        # Permute to [4, 3, H, W] so TIFF is interpreted as 4 timepoints of 3-channel images\n        demosaiced_transposed = np.transpose(demosaiced, (3, 2, 0, 1))\n        tifffile.imwrite(\n            output_file, demosaiced_transposed.astype(np.uint16), imagej=True, metadata={\"axes\": \"TCYX\"}\n        )\n        # print(f\"Saved TIFF stack to {output_file} (4 polarization angles \u00d7 3 color channels)\")\n    elif output_format.lower() == \"png\":\n        import matplotlib.pyplot as plt\n\n        angle_names = [\"0deg\", \"45deg\", \"90deg\", \"135deg\"]\n        for i, angle in enumerate(angle_names):\n            output_file = f\"{output_prefix}_{angle}.png\"\n\n            # Normalize to 0-1 for PNG\n            # HARDCODED: 4096 for 12-bit images\n            img = demosaiced[:, :, :, i] / 4096\n\n            plt.imsave(output_file, img)\n            # print(f\"Saved {angle} polarization to {output_file}\")\n    else:\n        raise ValueError(f\"Unsupported output format: {output_format}. Use 'tiff' or 'png'.\")\n\n    return demosaiced\n</code></pre>"},{"location":"reference/main/#photoelastimetry.main.cli_demosaic","title":"<code>cli_demosaic()</code>","text":"<p>Command line interface for de-mosaicing raw polarimetric images.</p> Source code in <code>photoelastimetry/main.py</code> <pre><code>def cli_demosaic():\n    \"\"\"Command line interface for de-mosaicing raw polarimetric images.\"\"\"\n    parser = argparse.ArgumentParser(description=\"De-mosaic raw polarimetric images into separate channels.\")\n    parser.add_argument(\n        \"input_file\",\n        type=str,\n        help=\"Path to the raw image file or directory (with --all flag).\",\n    )\n    parser.add_argument(\n        \"--width\",\n        type=int,\n        default=4096,\n        help=\"Image width in pixels (default: 4096).\",\n    )\n    parser.add_argument(\n        \"--height\",\n        type=int,\n        default=3000,\n        help=\"Image height in pixels (default: 3000).\",\n    )\n    parser.add_argument(\n        \"--dtype\",\n        type=str,\n        default=None,\n        choices=[\"uint8\", \"uint16\"],\n        help=\"Data type (uint8 or uint16). Auto-detected if not specified.\",\n    )\n    parser.add_argument(\n        \"--output-prefix\",\n        type=str,\n        default=None,\n        help=\"Prefix for output files (default: input filename without extension).\",\n    )\n    parser.add_argument(\n        \"--format\",\n        type=str,\n        default=\"tiff\",\n        choices=[\"tiff\", \"png\"],\n        help=\"Output format: 'tiff' for single stack, 'png' for 4 separate images (default: tiff).\",\n    )\n    parser.add_argument(\n        \"--all\",\n        action=\"store_true\",\n        help=\"Recursively process all .raw files in the input directory and subdirectories.\",\n    )\n    args = parser.parse_args()\n\n    metadata = {\n        \"width\": args.width,\n        \"height\": args.height,\n    }\n    if args.dtype:\n        metadata[\"dtype\"] = args.dtype\n\n    if args.all:\n        # Process all raw files recursively\n        if not os.path.isdir(args.input_file):\n            raise ValueError(f\"When using --all flag, input_file must be a directory. Got: {args.input_file}\")\n\n        # Find all .raw files recursively\n        from glob import glob\n\n        raw_files = glob(os.path.join(args.input_file, \"**\", \"*.raw\"), recursive=True)\n\n        if len(raw_files) == 0:\n            print(f\"No .raw files found in {args.input_file}\")\n            return\n\n        print(f\"Found {len(raw_files)} .raw files to process\")\n\n        # Process each file\n        from tqdm import tqdm\n\n        for raw_file in tqdm(raw_files, desc=\"Processing raw files\"):\n            try:\n                demosaic_raw_image(raw_file, metadata, args.output_prefix, args.format)\n            except Exception as e:\n                print(f\"Error processing {raw_file}: {e}\")\n                continue\n    else:\n        # Process single file\n        demosaic_raw_image(args.input_file, metadata, args.output_prefix, args.format)\n</code></pre>"},{"location":"reference/plotting/","title":"plotting","text":"<p>Visualization utilities and colormaps.</p> <p>This module provides specialized plotting functions and colormaps for visualizing stress fields and photoelastic data.</p>"},{"location":"reference/plotting/#photoelastimetry.plotting","title":"<code>plotting</code>","text":""},{"location":"reference/plotting/#photoelastimetry.plotting-functions","title":"Functions","text":""},{"location":"reference/plotting/#photoelastimetry.plotting.virino","title":"<code>virino()</code>","text":"<p>Defines the virino colormap, useful for plotting angular data.</p> <p>Returns:     The virino colormap</p> Source code in <code>photoelastimetry/plotting.py</code> <pre><code>def virino():\n    \"\"\"\n    Defines the virino colormap, useful for plotting angular data.\n\n    Returns:\n        The virino colormap\n    \"\"\"\n\n    cmap = matplotlib.colors.LinearSegmentedColormap.from_list(\"virino\", _virino_list)\n    return cmap\n</code></pre>"},{"location":"reference/plotting/#photoelastimetry.plotting.plot_optimization_history","title":"<code>plot_optimization_history(history, S_m_hat, filename=None)</code>","text":"<p>Plot the evolution of stress components and Stokes parameters during optimization.</p> <p>Parameters:</p> Name Type Description Default <code>history</code> <code>dict</code> <p>Dictionary containing optimization history with keys: - 'all_paths': list of dicts, each containing optimization path data - 'best_path_index': index of the path that led to the best solution</p> required <code>S_m_hat</code> <code>ndarray</code> <p>Measured normalized Stokes components, shape (3, 2) for RGB channels. Used to show target values.</p> required <code>filename</code> <code>str</code> <p>If provided, save figure to this filename instead of displaying.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>fig</code> <code>Figure</code> <p>The figure object.</p> Source code in <code>photoelastimetry/plotting.py</code> <pre><code>def plot_optimization_history(history, S_m_hat, filename=None):\n    \"\"\"\n    Plot the evolution of stress components and Stokes parameters during optimization.\n\n    Parameters\n    ----------\n    history : dict\n        Dictionary containing optimization history with keys:\n        - 'all_paths': list of dicts, each containing optimization path data\n        - 'best_path_index': index of the path that led to the best solution\n    S_m_hat : ndarray\n        Measured normalized Stokes components, shape (3, 2) for RGB channels.\n        Used to show target values.\n    filename : str, optional\n        If provided, save figure to this filename instead of displaying.\n\n    Returns\n    -------\n    fig : matplotlib.figure.Figure\n        The figure object.\n    \"\"\"\n    all_paths = history[\"all_paths\"]\n    best_path_index = history[\"best_path_index\"]\n\n    colors_rgb = [\"red\", \"green\", \"blue\"]\n\n    fig = plt.figure(figsize=(16, 10))\n    gs = fig.add_gridspec(3, 3, hspace=0.3, wspace=0.3)\n\n    # Plot 1: Stress components evolution (all paths)\n    ax1 = fig.add_subplot(gs[0, :])\n    for i, path in enumerate(all_paths):\n        stress_params = path[\"stress_params\"]\n        n_iter = len(stress_params)\n        iterations = np.arange(n_iter)\n        is_best = path[\"is_best\"]\n        alpha = 0.8 if is_best else 0.1\n        linewidth = 2 if is_best else 0.1\n        linestyle = \"-\" if is_best else \"-\"\n        markersize = 2 if is_best else 0.1\n\n        ax1.plot(\n            iterations,\n            stress_params[:, 0],\n            \"o-\",\n            alpha=alpha,\n            markersize=markersize,\n            linewidth=linewidth,\n            color=\"C0\",\n        )\n        ax1.plot(\n            iterations,\n            stress_params[:, 1],\n            \"s-\",\n            alpha=alpha,\n            markersize=markersize,\n            linewidth=linewidth,\n            color=\"C1\",\n        )\n        ax1.plot(\n            iterations,\n            stress_params[:, 2],\n            \"^-\",\n            alpha=alpha,\n            markersize=markersize,\n            linewidth=linewidth,\n            color=\"C2\",\n        )\n\n    # Add legend (using best path)\n    best_path = all_paths[best_path_index]\n    ax1.plot([], [], \"o-\", color=\"C0\", label=\"\u03c3_xx\", linewidth=2)\n    ax1.plot([], [], \"s-\", color=\"C1\", label=\"\u03c3_yy\", linewidth=2)\n    ax1.plot([], [], \"^-\", color=\"C2\", label=\"\u03c3_xy\", linewidth=2)\n    ax1.set_xlabel(\"Iteration (within each path)\")\n    ax1.set_ylabel(\"Stress (Pa)\")\n    ax1.set_title(\n        f\"Evolution of Stress Components ({len(all_paths)} optimization paths, best path highlighted)\"\n    )\n    ax1.legend()\n    # ax1.grid(True, alpha=0.3)\n\n    # Plot 2: Residual evolution (all paths)\n    ax2 = fig.add_subplot(gs[1, 0])\n    for i, path in enumerate(all_paths):\n        residuals = path[\"residuals\"]\n        n_iter = len(residuals)\n        iterations = np.arange(n_iter)\n        is_best = path[\"is_best\"]\n        alpha = 0.8 if is_best else 0.2\n        linewidth = 2 if is_best else 0.5\n\n        ax2.semilogy(\n            iterations, residuals, \"o-\", alpha=alpha, markersize=2 if is_best else 1, linewidth=linewidth\n        )\n    ax2.set_xlabel(\"Iteration (within each path)\")\n    ax2.set_ylabel(\"Residual (log scale)\")\n    ax2.set_title(\"Residual Evolution (All Paths)\")\n    ax2.grid(True, alpha=0.3)\n\n    # Plot 3: S1_hat evolution for RGB channels (best path only)\n    ax3 = fig.add_subplot(gs[1, 1])\n    S_predicted = best_path[\"S_predicted\"]\n    n_iter = len(S_predicted)\n    iterations = np.arange(n_iter)\n    for c, color in enumerate(colors_rgb):\n        ax3.plot(\n            iterations,\n            S_predicted[:, c, 0],\n            \"o-\",\n            color=color,\n            alpha=0.7,\n            markersize=2,\n            label=f\"{color.upper()} predicted\",\n        )\n        ax3.axhline(\n            S_m_hat[c, 0],\n            color=color,\n            linestyle=\"--\",\n            linewidth=2,\n            alpha=0.8,\n            label=f\"{color.upper()} measured\",\n        )\n    ax3.set_xlabel(\"Iteration\")\n    ax3.set_ylabel(\"S1_hat (normalized)\")\n    ax3.set_title(\"S1_hat Evolution - Best Path (RGB Channels)\")\n    ax3.legend(fontsize=8, ncol=2)\n    ax3.grid(True, alpha=0.3)\n\n    # Plot 4: S2_hat evolution for RGB channels (best path only)\n    ax4 = fig.add_subplot(gs[1, 2])\n    for c, color in enumerate(colors_rgb):\n        ax4.plot(\n            iterations,\n            S_predicted[:, c, 1],\n            \"s-\",\n            color=color,\n            alpha=0.7,\n            markersize=2,\n            label=f\"{color.upper()} predicted\",\n        )\n        ax4.axhline(\n            S_m_hat[c, 1],\n            color=color,\n            linestyle=\"--\",\n            linewidth=2,\n            alpha=0.8,\n            label=f\"{color.upper()} measured\",\n        )\n    ax4.set_xlabel(\"Iteration\")\n    ax4.set_ylabel(\"S2_hat (normalized)\")\n    ax4.set_title(\"S2_hat Evolution - Best Path (RGB Channels)\")\n    ax4.legend(fontsize=8, ncol=2)\n    ax4.grid(True, alpha=0.3)\n\n    # Plot 5: 3D trajectory in stress space (all paths)\n    ax5 = fig.add_subplot(gs[2, 0], projection=\"3d\")\n    for i, path in enumerate(all_paths):\n        stress_params = path[\"stress_params\"]\n        n_iter = len(stress_params)\n        iterations_path = np.arange(n_iter)\n        is_best = path[\"is_best\"]\n        alpha = 0.7 if is_best else 0.15\n        linewidth = 2 if is_best else 0.5\n        s = 20 if is_best else 5\n\n        scatter = ax5.scatter(\n            stress_params[:, 0],\n            stress_params[:, 1],\n            stress_params[:, 2],\n            c=iterations_path,\n            cmap=\"viridis\",\n            s=s,\n            alpha=alpha,\n        )\n        ax5.plot(\n            stress_params[:, 0],\n            stress_params[:, 1],\n            stress_params[:, 2],\n            \"k-\",\n            alpha=alpha,\n            linewidth=linewidth,\n        )\n\n        # Mark start and end points for best path only\n        if is_best:\n            ax5.scatter(\n                stress_params[0, 0],\n                stress_params[0, 1],\n                stress_params[0, 2],\n                color=\"green\",\n                s=100,\n                marker=\"o\",\n                label=\"Start (best)\",\n                edgecolors=\"black\",\n            )\n            ax5.scatter(\n                stress_params[-1, 0],\n                stress_params[-1, 1],\n                stress_params[-1, 2],\n                color=\"red\",\n                s=100,\n                marker=\"*\",\n                label=\"End (best)\",\n                edgecolors=\"black\",\n            )\n\n    ax5.set_xlabel(\"\u03c3_xx (Pa)\")\n    ax5.set_ylabel(\"\u03c3_yy (Pa)\")\n    ax5.set_zlabel(\"\u03c3_xy (Pa)\")\n    ax5.set_title(f\"Optimization Trajectories in Stress Space ({len(all_paths)} paths)\")\n    # ax5.legend()\n    plt.colorbar(scatter, ax=ax5, label=\"Iteration\", shrink=0.6)\n\n    # Plot 6: Final comparison of measured vs predicted (best path)\n    ax6 = fig.add_subplot(gs[2, 1:])\n    x_pos = np.arange(6)\n    measured = np.concatenate([S_m_hat[:, 0], S_m_hat[:, 1]])\n    S_predicted_best = best_path[\"S_predicted\"]\n    predicted = np.concatenate([S_predicted_best[-1, :, 0], S_predicted_best[-1, :, 1]])\n\n    width = 0.35\n    ax6.bar(x_pos - width / 2, measured, width, label=\"Measured\", alpha=0.7, color=\"steelblue\")\n    ax6.bar(x_pos + width / 2, predicted, width, label=\"Predicted (final)\", alpha=0.7, color=\"coral\")\n    ax6.set_xlabel(\"Stokes Component\")\n    ax6.set_ylabel(\"Normalized Value\")\n    ax6.set_title(\"Final Comparison: Measured vs Predicted Stokes Components (Best Path)\")\n    ax6.set_xticks(x_pos)\n    ax6.set_xticklabels([\"R S1\", \"G S1\", \"B S1\", \"R S2\", \"G S2\", \"B S2\"])\n    ax6.legend()\n    ax6.grid(True, alpha=0.3, axis=\"y\")\n\n    # Add summary text\n    final_residual = best_path[\"residuals\"][-1]\n    final_stress = best_path[\"stress_params\"][-1]\n    fig.text(\n        0.02,\n        0.98,\n        f\"Final residual: {final_residual:.2e}\\n\"\n        f\"Final \u03c3_xx: {final_stress[0]:.2e} Pa\\n\"\n        f\"Final \u03c3_yy: {final_stress[1]:.2e} Pa\\n\"\n        f\"Final \u03c3_xy: {final_stress[2]:.2e} Pa\\n\"\n        f\"Iterations: {n_iter}\",\n        verticalalignment=\"top\",\n        fontsize=10,\n        bbox=dict(boxstyle=\"round\", facecolor=\"wheat\", alpha=0.5),\n    )\n\n    if filename:\n        plt.savefig(filename, dpi=150, bbox_inches=\"tight\")\n        plt.close()\n    else:\n        plt.tight_layout()\n\n    return fig\n</code></pre>"},{"location":"reference/plotting/#photoelastimetry.plotting.plot_optimization_history_live","title":"<code>plot_optimization_history_live(history, S_m_hat, fig=None, axes=None)</code>","text":"<p>Create or update a live plot of optimization history (for interactive use).</p> <p>Parameters:</p> Name Type Description Default <code>history</code> <code>dict</code> <p>Dictionary containing optimization history (same format as plot_optimization_history).</p> required <code>S_m_hat</code> <code>ndarray</code> <p>Measured normalized Stokes components, shape (3, 2).</p> required <code>fig</code> <code>Figure</code> <p>Existing figure to update. If None, creates new figure.</p> <code>None</code> <code>axes</code> <code>list</code> <p>List of existing axes to update. If None, creates new axes.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>fig</code> <code>Figure</code> <p>The figure object.</p> <code>axes</code> <code>list</code> <p>List of axes objects.</p> Source code in <code>photoelastimetry/plotting.py</code> <pre><code>def plot_optimization_history_live(history, S_m_hat, fig=None, axes=None):\n    \"\"\"\n    Create or update a live plot of optimization history (for interactive use).\n\n    Parameters\n    ----------\n    history : dict\n        Dictionary containing optimization history (same format as plot_optimization_history).\n    S_m_hat : ndarray\n        Measured normalized Stokes components, shape (3, 2).\n    fig : matplotlib.figure.Figure, optional\n        Existing figure to update. If None, creates new figure.\n    axes : list, optional\n        List of existing axes to update. If None, creates new axes.\n\n    Returns\n    -------\n    fig : matplotlib.figure.Figure\n        The figure object.\n    axes : list\n        List of axes objects.\n    \"\"\"\n    stress_params = history[\"stress_params\"]\n    S_predicted = history[\"S_predicted\"]\n    residuals = history[\"residuals\"]\n    n_iter = len(residuals)\n    iterations = np.arange(n_iter)\n\n    colors_rgb = [\"red\", \"green\", \"blue\"]\n\n    # Create figure if needed\n    if fig is None:\n        fig, axes = plt.subplots(2, 3, figsize=(15, 8))\n        fig.suptitle(\"Live Optimization Progress\", fontsize=14, fontweight=\"bold\")\n        plt.ion()  # Enable interactive mode\n    else:\n        # Clear existing axes\n        for ax in axes.flat:\n            ax.clear()\n\n    axes = axes.flatten()\n\n    # Plot 1: Stress components\n    axes[0].plot(iterations, stress_params[:, 0], \"o-\", label=\"\u03c3_xx\", alpha=0.7, markersize=3)\n    axes[0].plot(iterations, stress_params[:, 1], \"s-\", label=\"\u03c3_yy\", alpha=0.7, markersize=3)\n    axes[0].plot(iterations, stress_params[:, 2], \"^-\", label=\"\u03c3_xy\", alpha=0.7, markersize=3)\n    axes[0].set_xlabel(\"Iteration\")\n    axes[0].set_ylabel(\"Stress (Pa)\")\n    axes[0].set_title(\"Stress Components\")\n    axes[0].legend(fontsize=8)\n    axes[0].grid(True, alpha=0.3)\n\n    # Plot 2: Residual\n    axes[1].semilogy(iterations, residuals, \"ko-\", markersize=3)\n    axes[1].set_xlabel(\"Iteration\")\n    axes[1].set_ylabel(\"Residual (log)\")\n    axes[1].set_title(\"Residual Evolution\")\n    axes[1].grid(True, alpha=0.3)\n\n    # Plot 3: S1_hat for RGB\n    for c, color in enumerate(colors_rgb):\n        axes[2].plot(\n            iterations,\n            S_predicted[:, c, 0],\n            \"o-\",\n            color=color,\n            alpha=0.7,\n            markersize=2,\n            label=f\"{color[0].upper()} pred\",\n        )\n        axes[2].axhline(S_m_hat[c, 0], color=color, linestyle=\"--\", linewidth=2, alpha=0.5)\n    axes[2].set_xlabel(\"Iteration\")\n    axes[2].set_ylabel(\"S1_hat\")\n    axes[2].set_title(\"S1_hat (RGB)\")\n    axes[2].legend(fontsize=7)\n    axes[2].grid(True, alpha=0.3)\n\n    # Plot 4: S2_hat for RGB\n    for c, color in enumerate(colors_rgb):\n        axes[3].plot(\n            iterations,\n            S_predicted[:, c, 1],\n            \"s-\",\n            color=color,\n            alpha=0.7,\n            markersize=2,\n            label=f\"{color[0].upper()} pred\",\n        )\n        axes[3].axhline(S_m_hat[c, 1], color=color, linestyle=\"--\", linewidth=2, alpha=0.5)\n    axes[3].set_xlabel(\"Iteration\")\n    axes[3].set_ylabel(\"S2_hat\")\n    axes[3].set_title(\"S2_hat (RGB)\")\n    axes[3].legend(fontsize=7)\n    axes[3].grid(True, alpha=0.3)\n\n    # Plot 5: Trajectory projection (sigma_xx vs sigma_yy)\n    axes[4].plot(stress_params[:, 0], stress_params[:, 1], \"o-\", markersize=3, alpha=0.7, color=\"navy\")\n    axes[4].scatter(\n        stress_params[0, 0],\n        stress_params[0, 1],\n        color=\"green\",\n        s=100,\n        marker=\"o\",\n        label=\"Start\",\n        edgecolors=\"black\",\n        zorder=5,\n    )\n    axes[4].scatter(\n        stress_params[-1, 0],\n        stress_params[-1, 1],\n        color=\"red\",\n        s=100,\n        marker=\"*\",\n        label=\"End\",\n        edgecolors=\"black\",\n        zorder=5,\n    )\n    axes[4].set_xlabel(\"\u03c3_xx (Pa)\")\n    axes[4].set_ylabel(\"\u03c3_yy (Pa)\")\n    axes[4].set_title(\"Stress Trajectory (xy plane)\")\n    axes[4].legend(fontsize=8)\n    axes[4].grid(True, alpha=0.3)\n\n    # Plot 6: Final comparison\n    x_pos = np.arange(6)\n    measured = np.concatenate([S_m_hat[:, 0], S_m_hat[:, 1]])\n    predicted = np.concatenate([S_predicted[-1, :, 0], S_predicted[-1, :, 1]])\n\n    width = 0.35\n    axes[5].bar(x_pos - width / 2, measured, width, label=\"Measured\", alpha=0.7, color=\"steelblue\")\n    axes[5].bar(x_pos + width / 2, predicted, width, label=\"Predicted\", alpha=0.7, color=\"coral\")\n    axes[5].set_xlabel(\"Component\")\n    axes[5].set_ylabel(\"Value\")\n    axes[5].set_title(\"Measured vs Predicted\")\n    axes[5].set_xticks(x_pos)\n    axes[5].set_xticklabels([\"RS1\", \"GS1\", \"BS1\", \"RS2\", \"GS2\", \"BS2\"], fontsize=8)\n    axes[5].legend(fontsize=8)\n    axes[5].grid(True, alpha=0.3, axis=\"y\")\n\n    fig.tight_layout()\n    fig.canvas.draw()\n    fig.canvas.flush_events()\n\n    return fig, axes.reshape(2, 3)\n</code></pre>"},{"location":"reference/solver/","title":"solver","text":"<p>Main solver module with high-level API.</p> <p>The solver subpackage provides multiple approaches for recovering stress fields from polarimetric images. This module exports the main functions from all solver submodules for convenient access.</p>"},{"location":"reference/solver/#overview","title":"Overview","text":"<p>Three complementary stress inversion methods are available:</p> <ol> <li>Stokes-based solver - Uses normalized Stokes components for pixel-wise inversion (recommended for most cases)</li> <li>Intensity-based solver - Works directly with raw polarization intensities</li> <li>Equilibrium solver - Global inversion enforcing mechanical equilibrium via Airy stress function</li> </ol>"},{"location":"reference/solver/#photoelastimetry.solver","title":"<code>solver</code>","text":""},{"location":"reference/stokes_solver/","title":"solver.stokes_solver","text":"<p>Stokes-based pixel-wise stress inversion.</p> <p>This module implements stress field recovery using normalized Stokes components computed from polarimetric measurements. This is the primary and recommended method for most photoelastic analysis tasks.</p>"},{"location":"reference/stokes_solver/#key-functions","title":"Key Functions","text":"<ul> <li><code>compute_stokes_components()</code> - Calculate Stokes parameters from intensity measurements</li> <li><code>compute_normalized_stokes()</code> - Normalize Stokes components for analysis</li> <li><code>recover_stress_map_stokes()</code> - Main function for stress field recovery</li> <li><code>predict_stokes()</code> - Forward model for validation</li> </ul>"},{"location":"reference/stokes_solver/#photoelastimetry.solver.stokes_solver","title":"<code>stokes_solver</code>","text":"<p>Local stress measurement using polarimetric imaging.</p> <p>This module implements the local stress measurement algorithm using Mueller matrix calculus and multi-wavelength polarimetry to recover the full 2D stress tensor at each pixel from polarimetric images.</p>"},{"location":"reference/stokes_solver/#photoelastimetry.solver.stokes_solver-functions","title":"Functions","text":""},{"location":"reference/stokes_solver/#photoelastimetry.solver.stokes_solver.compute_stokes_components","title":"<code>compute_stokes_components(I_0, I_45, I_90, I_135)</code>","text":"<p>Compute the Stokes vector components (S0, S1, S2) from intensity measurements.</p> <p>Parameters:</p> Name Type Description Default <code>I_0</code> <code>array - like</code> <p>Intensity at polarizer angle 0 degrees.</p> required <code>I_45</code> <code>array - like</code> <p>Intensity at polarizer angle 45 degrees.</p> required <code>I_90</code> <code>array - like</code> <p>Intensity at polarizer angle 90 degrees.</p> required <code>I_135</code> <code>array - like</code> <p>Intensity at polarizer angle 135 degrees.</p> required <p>Returns:</p> Name Type Description <code>S0</code> <code>array - like</code> <p>Total intensity (sum of orthogonal components).</p> <code>S1</code> <code>array - like</code> <p>Linear polarisation along 0-90 degrees.</p> <code>S2</code> <code>array - like</code> <p>Linear polarisation along 45-135 degrees.</p> Source code in <code>photoelastimetry/solver/stokes_solver.py</code> <pre><code>def compute_stokes_components(I_0, I_45, I_90, I_135):\n    \"\"\"\n    Compute the Stokes vector components (S0, S1, S2) from intensity measurements.\n\n    Parameters\n    ----------\n    I_0 : array-like\n        Intensity at polarizer angle 0 degrees.\n    I_45 : array-like\n        Intensity at polarizer angle 45 degrees.\n    I_90 : array-like\n        Intensity at polarizer angle 90 degrees.\n    I_135 : array-like\n        Intensity at polarizer angle 135 degrees.\n\n    Returns\n    -------\n    S0 : array-like\n        Total intensity (sum of orthogonal components).\n    S1 : array-like\n        Linear polarisation along 0-90 degrees.\n    S2 : array-like\n        Linear polarisation along 45-135 degrees.\n    \"\"\"\n    S0 = I_0 + I_90\n    S1 = I_0 - I_90\n    S2 = I_45 - I_135\n    return S0, S1, S2\n</code></pre>"},{"location":"reference/stokes_solver/#photoelastimetry.solver.stokes_solver.compute_normalized_stokes","title":"<code>compute_normalized_stokes(S0, S1, S2)</code>","text":"<p>Compute normalized Stokes vector components.</p> <p>Parameters:</p> Name Type Description Default <code>S0</code> <code>array - like</code> <p>Total intensity Stokes parameter.</p> required <code>S1</code> <code>array - like</code> <p>First linear polarisation Stokes parameter.</p> required <code>S2</code> <code>array - like</code> <p>Second linear polarisation Stokes parameter.</p> required <p>Returns:</p> Name Type Description <code>S1_hat</code> <code>array - like</code> <p>Normalized S1 component (S1/S0).</p> <code>S2_hat</code> <code>array - like</code> <p>Normalized S2 component (S2/S0).</p> Source code in <code>photoelastimetry/solver/stokes_solver.py</code> <pre><code>def compute_normalized_stokes(S0, S1, S2):\n    \"\"\"\n    Compute normalized Stokes vector components.\n\n    Parameters\n    ----------\n    S0 : array-like\n        Total intensity Stokes parameter.\n    S1 : array-like\n        First linear polarisation Stokes parameter.\n    S2 : array-like\n        Second linear polarisation Stokes parameter.\n\n    Returns\n    -------\n    S1_hat : array-like\n        Normalized S1 component (S1/S0).\n    S2_hat : array-like\n        Normalized S2 component (S2/S0).\n    \"\"\"\n    S0_safe = np.where(S0 == 0, 1e-10, S0)\n    S1_hat = S1 / S0_safe\n    S2_hat = S2 / S0_safe\n    return S1_hat, S2_hat\n</code></pre>"},{"location":"reference/stokes_solver/#photoelastimetry.solver.stokes_solver.predict_stokes","title":"<code>predict_stokes(sigma_xx, sigma_yy, sigma_xy, C, nu, L, wavelength, S_i_hat)</code>","text":"<p>Predict normalized Stokes vector components from stress tensor.</p> <p>Parameters:</p> Name Type Description Default <code>sigma_xx</code> <code>float</code> <p>Normal stress component in x direction (Pa).</p> required <code>sigma_yy</code> <code>float</code> <p>Normal stress component in y direction (Pa).</p> required <code>sigma_xy</code> <code>float</code> <p>Shear stress component (Pa).</p> required <code>C</code> <code>float</code> <p>Stress-optic coefficient (1/Pa).</p> required <code>nu</code> <code>float</code> <p>Solid fraction (use 1.0 for solid samples).</p> required <code>L</code> <code>float</code> <p>Sample thickness (m).</p> required <code>wavelength</code> <code>float</code> <p>Wavelength of light (m).</p> required <code>S_i_hat</code> <code>array - like</code> <p>Incoming normalized Stokes vector [S1_hat, S2_hat] or [S1_hat, S2_hat, S3_hat]. If 2 elements, S3_hat is assumed to be 0 (no circular polarization). If 3 elements, S3_hat represents circular polarization component.</p> required <p>Returns:</p> Name Type Description <code>S_p_hat</code> <code>ndarray</code> <p>Predicted normalized Stokes components [S1_hat, S2_hat].</p> Source code in <code>photoelastimetry/solver/stokes_solver.py</code> <pre><code>def predict_stokes(sigma_xx, sigma_yy, sigma_xy, C, nu, L, wavelength, S_i_hat):\n    \"\"\"\n    Predict normalized Stokes vector components from stress tensor.\n\n    Parameters\n    ----------\n    sigma_xx : float\n        Normal stress component in x direction (Pa).\n    sigma_yy : float\n        Normal stress component in y direction (Pa).\n    sigma_xy : float\n        Shear stress component (Pa).\n    C : float\n        Stress-optic coefficient (1/Pa).\n    nu : float\n        Solid fraction (use 1.0 for solid samples).\n    L : float\n        Sample thickness (m).\n    wavelength : float\n        Wavelength of light (m).\n    S_i_hat : array-like\n        Incoming normalized Stokes vector [S1_hat, S2_hat] or [S1_hat, S2_hat, S3_hat].\n        If 2 elements, S3_hat is assumed to be 0 (no circular polarization).\n        If 3 elements, S3_hat represents circular polarization component.\n\n    Returns\n    -------\n    S_p_hat : ndarray\n        Predicted normalized Stokes components [S1_hat, S2_hat].\n    \"\"\"\n    theta = compute_principal_angle(sigma_xx, sigma_yy, sigma_xy)\n    delta = compute_retardance(sigma_xx, sigma_yy, sigma_xy, C, nu, L, wavelength)\n\n    M = mueller_matrix(theta, delta)\n\n    # Extend S_i_hat to full Stokes vector\n    S_i_hat = np.asarray(S_i_hat)\n    if len(S_i_hat) == 2:\n        # Backward compatibility: assume S3 = 0 (no circular polarization)\n        S_i_full = np.array([1.0, S_i_hat[0], S_i_hat[1], 0.0])\n    elif len(S_i_hat) == 3:\n        # Use provided circular component\n        S_i_full = np.array([1.0, S_i_hat[0], S_i_hat[1], S_i_hat[2]])\n    else:\n        raise ValueError(f\"S_i_hat must have 2 or 3 elements, got {len(S_i_hat)}\")\n\n    # Apply Mueller matrix\n    S_m = M @ S_i_full\n\n    # Return normalized components (excluding S0)\n    S_p_hat = S_m[1:3]\n\n    return S_p_hat\n</code></pre>"},{"location":"reference/stokes_solver/#photoelastimetry.solver.stokes_solver.compute_residual","title":"<code>compute_residual(stress_params, S_m_hat, wavelengths, C_values, nu, L, S_i_hat)</code>","text":"<p>Compute residual between measured and predicted Stokes components.</p> <p>Parameters:</p> Name Type Description Default <code>stress_params</code> <code>array - like</code> <p>Stress tensor components [sigma_xx, sigma_yy, sigma_xy].</p> required <code>S_m_hat</code> <code>ndarray</code> <p>Measured normalized Stokes components, shape (3, 2) for RGB channels.</p> required <code>wavelengths</code> <code>array - like</code> <p>Wavelengths for R, G, B channels (m).</p> required <code>C_values</code> <code>array - like</code> <p>Stress-optic coefficients for R, G, B channels (1/Pa).</p> required <code>nu</code> <code>float</code> <p>Solid fraction (use 1.0 for solid samples).</p> required <code>L</code> <code>float</code> <p>Sample thickness (m).</p> required <code>S_i_hat</code> <code>array - like</code> <p>Incoming normalized Stokes vector [S1_hat, S2_hat] or [S1_hat, S2_hat, S3_hat].</p> required <p>Returns:</p> Name Type Description <code>residual</code> <code>float</code> <p>Sum of squared residuals across all colour channels.</p> Source code in <code>photoelastimetry/solver/stokes_solver.py</code> <pre><code>def compute_residual(stress_params, S_m_hat, wavelengths, C_values, nu, L, S_i_hat):\n    \"\"\"\n    Compute residual between measured and predicted Stokes components.\n\n    Parameters\n    ----------\n    stress_params : array-like\n        Stress tensor components [sigma_xx, sigma_yy, sigma_xy].\n    S_m_hat : ndarray\n        Measured normalized Stokes components, shape (3, 2) for RGB channels.\n    wavelengths : array-like\n        Wavelengths for R, G, B channels (m).\n    C_values : array-like\n        Stress-optic coefficients for R, G, B channels (1/Pa).\n    nu : float\n        Solid fraction (use 1.0 for solid samples).\n    L : float\n        Sample thickness (m).\n    S_i_hat : array-like\n        Incoming normalized Stokes vector [S1_hat, S2_hat] or [S1_hat, S2_hat, S3_hat].\n\n    Returns\n    -------\n    residual : float\n        Sum of squared residuals across all colour channels.\n    \"\"\"\n    sigma_xx, sigma_yy, sigma_xy = stress_params\n\n    residual = 0.0\n    for c in range(3):  # R, G, B\n        S_p_hat = predict_stokes(\n            sigma_xx,\n            sigma_yy,\n            sigma_xy,\n            C_values[c],\n            nu,\n            L,\n            wavelengths[c],\n            S_i_hat,\n        )\n        diff = S_m_hat[c] - S_p_hat\n        residual += np.sum(diff**2)\n\n    return residual\n</code></pre>"},{"location":"reference/stokes_solver/#photoelastimetry.solver.stokes_solver.recover_stress_tensor","title":"<code>recover_stress_tensor(S_m_hat, wavelengths, C_values, nu, L, S_i_hat, initial_guess=None, track_history=False, max_fringes=6)</code>","text":"<p>Recover stress tensor components by minimizing residual.</p> <p>Parameters:</p> Name Type Description Default <code>S_m_hat</code> <code>ndarray</code> <p>Measured normalized Stokes components, shape (3, 2) for RGB channels. Each row is [S1_hat, S2_hat] for a colour channel.</p> required <code>wavelengths</code> <code>array - like</code> <p>Wavelengths for R, G, B channels (m).</p> required <code>C_values</code> <code>array - like</code> <p>Stress-optic coefficients for R, G, B channels (1/Pa).</p> required <code>nu</code> <code>float</code> <p>Solid fraction (use 1.0 for solid samples).</p> required <code>L</code> <code>float</code> <p>Sample thickness (m).</p> required <code>S_i_hat</code> <code>array - like</code> <p>Incoming normalized Stokes vector [S1_hat, S2_hat] or [S1_hat, S2_hat, S3_hat].</p> required <code>initial_guess</code> <code>array - like</code> <p>Initial guess for stress tensor [sigma_xx, sigma_yy, sigma_xy]. Default is [1, 1, 1].</p> <code>None</code> <code>track_history</code> <code>bool</code> <p>If True, track optimization history for debugging plots. Default is False.</p> <code>False</code> <code>max_fringes</code> <code>float</code> <p>Maximum expected fringe order. Used to set bounds on stress components. Default is 6 fringes, which corresponds to ~1.7 MPa for typical materials.</p> <code>6</code> <p>Returns:</p> Name Type Description <code>stress_tensor</code> <code>ndarray</code> <p>Recovered stress tensor components [sigma_xx, sigma_yy, sigma_xy].</p> <code>success</code> <code>bool</code> <p>Whether optimization was successful.</p> <code>history</code> <code>(dict, optional)</code> <p>Only returned if track_history=True. Contains: - 'all_paths': list of dicts, each containing the optimization path from a start point - 'best_path_index': index of the path that led to the best solution</p> Source code in <code>photoelastimetry/solver/stokes_solver.py</code> <pre><code>def recover_stress_tensor(\n    S_m_hat, wavelengths, C_values, nu, L, S_i_hat, initial_guess=None, track_history=False, max_fringes=6\n):\n    \"\"\"\n    Recover stress tensor components by minimizing residual.\n\n    Parameters\n    ----------\n    S_m_hat : ndarray\n        Measured normalized Stokes components, shape (3, 2) for RGB channels.\n        Each row is [S1_hat, S2_hat] for a colour channel.\n    wavelengths : array-like\n        Wavelengths for R, G, B channels (m).\n    C_values : array-like\n        Stress-optic coefficients for R, G, B channels (1/Pa).\n    nu : float\n        Solid fraction (use 1.0 for solid samples).\n    L : float\n        Sample thickness (m).\n    S_i_hat : array-like\n        Incoming normalized Stokes vector [S1_hat, S2_hat] or [S1_hat, S2_hat, S3_hat].\n    initial_guess : array-like, optional\n        Initial guess for stress tensor [sigma_xx, sigma_yy, sigma_xy].\n        Default is [1, 1, 1].\n    track_history : bool, optional\n        If True, track optimization history for debugging plots. Default is False.\n    max_fringes : float, optional\n        Maximum expected fringe order. Used to set bounds on stress components.\n        Default is 6 fringes, which corresponds to ~1.7 MPa for typical materials.\n\n    Returns\n    -------\n    stress_tensor : ndarray\n        Recovered stress tensor components [sigma_xx, sigma_yy, sigma_xy].\n    success : bool\n        Whether optimization was successful.\n    history : dict, optional\n        Only returned if track_history=True. Contains:\n        - 'all_paths': list of dicts, each containing the optimization path from a start point\n        - 'best_path_index': index of the path that led to the best solution\n    \"\"\"\n    if initial_guess is None:\n        initial_guess = np.array([1.0, 1.0, 0.0])\n\n    # Run core optimization\n    if track_history:\n        result, all_paths = _optimize_stress_tensor(\n            S_m_hat,\n            wavelengths,\n            C_values,\n            nu,\n            L,\n            S_i_hat,\n            initial_guess,\n            max_fringes,\n            callback=None,\n            track_all_paths=True,\n        )\n\n        # Find which path was the best\n        best_path_index = None\n        for i, path in enumerate(all_paths):\n            if path[\"is_best\"]:\n                best_path_index = i\n                break\n\n        history = {\"all_paths\": all_paths, \"best_path_index\": best_path_index}\n        return result.x, result.success, history\n    else:\n        result = _optimize_stress_tensor(\n            S_m_hat,\n            wavelengths,\n            C_values,\n            nu,\n            L,\n            S_i_hat,\n            initial_guess,\n            max_fringes,\n            callback=None,\n            track_all_paths=False,\n        )\n        return result.x, result.success\n</code></pre>"},{"location":"reference/stokes_solver/#photoelastimetry.solver.stokes_solver.recover_stress_tensor_live","title":"<code>recover_stress_tensor_live(S_m_hat, wavelengths, C_values, nu, L, S_i_hat, initial_guess=None, update_interval=5, max_fringes=6)</code>","text":"<p>Recover stress tensor with live plotting of optimization progress.</p> <p>This function is useful for debugging and understanding the optimization process for a single pixel. It creates a live-updating plot that shows how the stress components and predicted Stokes parameters evolve during optimization.</p> <p>Parameters:</p> Name Type Description Default <code>S_m_hat</code> <code>ndarray</code> <p>Measured normalized Stokes components, shape (3, 2) for RGB channels.</p> required <code>wavelengths</code> <code>array - like</code> <p>Wavelengths for R, G, B channels (m).</p> required <code>C_values</code> <code>array - like</code> <p>Stress-optic coefficients for R, G, B channels (1/Pa).</p> required <code>nu</code> <code>float</code> <p>Solid fraction (use 1.0 for solid samples).</p> required <code>L</code> <code>float</code> <p>Sample thickness (m).</p> required <code>S_i_hat</code> <code>array - like</code> <p>Incoming normalized Stokes vector [S1_hat, S2_hat] or [S1_hat, S2_hat, S3_hat].</p> required <code>initial_guess</code> <code>array - like</code> <p>Initial guess for stress tensor [sigma_xx, sigma_yy, sigma_xy].</p> <code>None</code> <code>update_interval</code> <code>int</code> <p>Update plot every N iterations. Default is 5.</p> <code>5</code> <code>max_fringes</code> <code>float</code> <p>Maximum expected fringe order for setting bounds. Default is 6.</p> <code>6</code> <p>Returns:</p> Name Type Description <code>stress_tensor</code> <code>ndarray</code> <p>Recovered stress tensor components [sigma_xx, sigma_yy, sigma_xy].</p> <code>success</code> <code>bool</code> <p>Whether optimization was successful.</p> <code>history</code> <code>dict</code> <p>Optimization history for further analysis.</p> <code>fig</code> <code>Figure</code> <p>The figure object (will be kept open).</p> Source code in <code>photoelastimetry/solver/stokes_solver.py</code> <pre><code>def recover_stress_tensor_live(\n    S_m_hat, wavelengths, C_values, nu, L, S_i_hat, initial_guess=None, update_interval=5, max_fringes=6\n):\n    \"\"\"\n    Recover stress tensor with live plotting of optimization progress.\n\n    This function is useful for debugging and understanding the optimization process\n    for a single pixel. It creates a live-updating plot that shows how the stress\n    components and predicted Stokes parameters evolve during optimization.\n\n    Parameters\n    ----------\n    S_m_hat : ndarray\n        Measured normalized Stokes components, shape (3, 2) for RGB channels.\n    wavelengths : array-like\n        Wavelengths for R, G, B channels (m).\n    C_values : array-like\n        Stress-optic coefficients for R, G, B channels (1/Pa).\n    nu : float\n        Solid fraction (use 1.0 for solid samples).\n    L : float\n        Sample thickness (m).\n    S_i_hat : array-like\n        Incoming normalized Stokes vector [S1_hat, S2_hat] or [S1_hat, S2_hat, S3_hat].\n    initial_guess : array-like, optional\n        Initial guess for stress tensor [sigma_xx, sigma_yy, sigma_xy].\n    update_interval : int, optional\n        Update plot every N iterations. Default is 5.\n    max_fringes : float, optional\n        Maximum expected fringe order for setting bounds. Default is 6.\n\n    Returns\n    -------\n    stress_tensor : ndarray\n        Recovered stress tensor components [sigma_xx, sigma_yy, sigma_xy].\n    success : bool\n        Whether optimization was successful.\n    history : dict\n        Optimization history for further analysis.\n    fig : matplotlib.figure.Figure\n        The figure object (will be kept open).\n    \"\"\"\n    import matplotlib.pyplot as plt\n\n    from photoelastimetry.plotting import plot_optimization_history_live\n\n    if initial_guess is None:\n        initial_guess = np.array([1.0, 1.0, 0.0])\n\n    # Storage for tracking\n    history = {\"stress_params\": [], \"S_predicted\": [], \"residuals\": []}\n    fig, axes = None, None\n    iteration_count = [0]  # Use list to allow modification in nested function\n\n    def callback_func(xk):\n        \"\"\"Callback with live plotting.\"\"\"\n        # Store current state\n        history[\"stress_params\"].append(xk.copy())\n\n        S_pred_all = np.zeros((3, 2))\n        for c in range(3):\n            S_pred_all[c] = predict_stokes(xk[0], xk[1], xk[2], C_values[c], nu, L, wavelengths[c], S_i_hat)\n        history[\"S_predicted\"].append(S_pred_all.copy())\n\n        residual = compute_residual(xk, S_m_hat, wavelengths, C_values, nu, L, S_i_hat)\n        history[\"residuals\"].append(residual)\n\n        # Update plot periodically\n        iteration_count[0] += 1\n        if iteration_count[0] % update_interval == 0 or iteration_count[0] == 1:\n            nonlocal fig, axes\n            # Convert to arrays for plotting\n            hist_for_plot = {\n                \"stress_params\": np.array(history[\"stress_params\"]),\n                \"S_predicted\": np.array(history[\"S_predicted\"]),\n                \"residuals\": np.array(history[\"residuals\"]),\n            }\n            fig, axes = plot_optimization_history_live(hist_for_plot, S_m_hat, fig, axes)\n            plt.pause(0.01)\n\n    # Run core optimization with live plotting callback\n    result = _optimize_stress_tensor(\n        S_m_hat, wavelengths, C_values, nu, L, S_i_hat, initial_guess, max_fringes, callback=callback_func\n    )\n\n    # Final update\n    history[\"stress_params\"] = np.array(history[\"stress_params\"])\n    history[\"S_predicted\"] = np.array(history[\"S_predicted\"])\n    history[\"residuals\"] = np.array(history[\"residuals\"])\n\n    fig, axes = plot_optimization_history_live(history, S_m_hat, fig, axes)\n    plt.ioff()  # Turn off interactive mode\n\n    return result.x, result.success, history, fig\n</code></pre>"},{"location":"reference/stokes_solver/#photoelastimetry.solver.stokes_solver.compute_solid_fraction","title":"<code>compute_solid_fraction(S0, S_ref, mu, L)</code>","text":"<p>Compute solid fraction from intensity using Beer-Lambert law.</p> <p>Parameters:</p> Name Type Description Default <code>S0</code> <code>array - like</code> <p>Measured intensity (from colour channel with absorptive dye).</p> required <code>S_ref</code> <code>float</code> <p>Reference light intensity before passing through sample.</p> required <code>mu</code> <code>float</code> <p>Absorption coefficient for the colour channel (calibrated parameter).</p> required <code>L</code> <code>float</code> <p>Sample thickness (m).</p> required <p>Returns:</p> Name Type Description <code>nu</code> <code>array - like</code> <p>Solid fraction values.</p> Source code in <code>photoelastimetry/solver/stokes_solver.py</code> <pre><code>def compute_solid_fraction(S0, S_ref, mu, L):\n    \"\"\"\n    Compute solid fraction from intensity using Beer-Lambert law.\n\n    Parameters\n    ----------\n    S0 : array-like\n        Measured intensity (from colour channel with absorptive dye).\n    S_ref : float\n        Reference light intensity before passing through sample.\n    mu : float\n        Absorption coefficient for the colour channel (calibrated parameter).\n    L : float\n        Sample thickness (m).\n\n    Returns\n    -------\n    nu : array-like\n        Solid fraction values.\n    \"\"\"\n    # Beer-Lambert: S0 = S_ref * exp(-mu * nu * L)\n    # Solving for nu: nu = -ln(S0 / S_ref) / (mu * L)\n    S0_safe = np.maximum(S0, 1e-10)\n    nu = -np.log(S0_safe / S_ref) / (mu * L)\n    return nu\n</code></pre>"},{"location":"reference/stokes_solver/#photoelastimetry.solver.stokes_solver.recover_stress_map_stokes","title":"<code>recover_stress_map_stokes(image_stack, wavelengths, C_values, nu, L, S_i_hat, n_jobs=-1)</code>","text":"<p>Recover full 2D stress tensor map from polarimetric image stack using Stokes method.</p> <p>Parameters:</p> Name Type Description Default <code>image_stack</code> <code>ndarray</code> <p>Image stack of shape [H, W, 3, 4] where: - H, W are image dimensions - 3 colour channels (R, G, B) - 4 polarisation angles (0, 45, 90, 135 degrees)</p> required <code>wavelengths</code> <code>array - like</code> <p>Wavelengths for R, G, B channels (m).</p> required <code>C_values</code> <code>array - like</code> <p>Stress-optic coefficients for R, G, B channels (1/Pa).</p> required <code>nu</code> <code>float or ndarray</code> <p>Solid fraction. Use 1.0 for solid samples. Can be scalar or array matching image dimensions.</p> required <code>L</code> <code>float</code> <p>Sample thickness (m).</p> required <code>S_i_hat</code> <code>array - like</code> <p>Incoming normalized Stokes vector [S1_hat, S2_hat] or [S1_hat, S2_hat, S3_hat].</p> required <code>n_jobs</code> <code>int</code> <p>Number of parallel jobs. -1 uses all available cores (default: -1).</p> <code>-1</code> <p>Returns:</p> Name Type Description <code>stress_map</code> <code>ndarray</code> <p>Array of shape [H, W, 3] containing [sigma_xx, sigma_yy, sigma_xy] in Pa.</p> Source code in <code>photoelastimetry/solver/stokes_solver.py</code> <pre><code>def recover_stress_map_stokes(\n    image_stack,\n    wavelengths,\n    C_values,\n    nu,\n    L,\n    S_i_hat,\n    n_jobs=-1,\n):\n    \"\"\"\n    Recover full 2D stress tensor map from polarimetric image stack using Stokes method.\n\n    Parameters\n    ----------\n    image_stack : ndarray\n        Image stack of shape [H, W, 3, 4] where:\n        - H, W are image dimensions\n        - 3 colour channels (R, G, B)\n        - 4 polarisation angles (0, 45, 90, 135 degrees)\n    wavelengths : array-like\n        Wavelengths for R, G, B channels (m).\n    C_values : array-like\n        Stress-optic coefficients for R, G, B channels (1/Pa).\n    nu : float or ndarray\n        Solid fraction. Use 1.0 for solid samples.\n        Can be scalar or array matching image dimensions.\n    L : float\n        Sample thickness (m).\n    S_i_hat : array-like\n        Incoming normalized Stokes vector [S1_hat, S2_hat] or [S1_hat, S2_hat, S3_hat].\n    n_jobs : int, optional\n        Number of parallel jobs. -1 uses all available cores (default: -1).\n\n    Returns\n    -------\n    stress_map : ndarray\n        Array of shape [H, W, 3] containing [sigma_xx, sigma_yy, sigma_xy] in Pa.\n    \"\"\"\n    from joblib import Parallel, delayed\n\n    H, W, _, _ = image_stack.shape\n    stress_map = np.zeros((H, W, 3), dtype=np.float32)\n\n    # Create list of all pixel coordinates\n    pixel_coords = [(y, x) for y in range(H) for x in range(W)]\n\n    # Create arguments for each pixel\n    pixel_args = [(y, x, image_stack, wavelengths, C_values, nu, L, S_i_hat) for y, x in pixel_coords]\n\n    # Process pixels in parallel\n    results = Parallel(n_jobs=n_jobs)(\n        delayed(_process_pixel)(args) for args in tqdm(pixel_args, desc=\"Processing pixels\")\n    )\n\n    # Fill in the stress map\n    for y, x, stress_tensor in results:\n        stress_map[y, x, :] = stress_tensor\n\n    return stress_map\n</code></pre>"}]}